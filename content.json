{"meta":{"title":"RACx0","subtitle":"what is life?","description":"what is life?","author":"OriginalS","url":"http://originals-tz.github.io"},"pages":[{"title":"tags","date":"2018-05-15T05:22:48.431Z","updated":"2018-03-21T13:16:52.000Z","comments":true,"path":"tags/index.html","permalink":"http://originals-tz.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"STL之List","slug":"STL_List","date":"2018-08-13T16:00:00.000Z","updated":"2018-08-21T02:29:28.424Z","comments":true,"path":"2018/08/14/STL_List/","link":"","permalink":"http://originals-tz.github.io/2018/08/14/STL_List/","excerpt":"List的好处学过数据结构都知道，List对空间的使用十分精准，绝不浪费，而且插入和移除元素的成本很低 但是如果需要经常访问元素，那么效率可能就不如Vector","text":"List的好处学过数据结构都知道，List对空间的使用十分精准，绝不浪费，而且插入和移除元素的成本很低 但是如果需要经常访问元素，那么效率可能就不如Vector List的节点 写过链表的人都知道，List本身和List的节点是不同的结构，需要分开设计 123456789struct _List_node_base &#123; _List_node_base* _M_next; _List_node_base* _M_prev;&#125;;template &lt;class _Tp&gt;struct _List_node : public _List_node_base &#123; _Tp _M_data;&#125;; 节点如上，可以看出是一个双向链表 List迭代器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263struct _List_iterator_base &#123; typedef size_t size_type; typedef ptrdiff_t difference_type; typedef bidirectional_iterator_tag iterator_category; _List_node_base* _M_node; _List_iterator_base(_List_node_base* __x) : _M_node(__x) &#123;&#125; _List_iterator_base() &#123;&#125; void _M_incr() &#123; _M_node = _M_node-&gt;_M_next; &#125; //移动到后一个节点 void _M_decr() &#123; _M_node = _M_node-&gt;_M_prev; &#125; //移动到前一个节点 bool operator==(const _List_iterator_base&amp; __x) const &#123; return _M_node == __x._M_node; &#125; bool operator!=(const _List_iterator_base&amp; __x) const &#123; return _M_node != __x._M_node; &#125;&#125;; template&lt;class _Tp, class _Ref, class _Ptr&gt;struct _List_iterator : public _List_iterator_base &#123; typedef _List_iterator&lt;_Tp,_Tp&amp;,_Tp*&gt; iterator; typedef _List_iterator&lt;_Tp,const _Tp&amp;,const _Tp*&gt; const_iterator; typedef _List_iterator&lt;_Tp,_Ref,_Ptr&gt; _Self; typedef _Tp value_type; typedef _Ptr pointer; typedef _Ref reference; typedef _List_node&lt;_Tp&gt; _Node; _List_iterator(_Node* __x) : _List_iterator_base(__x) &#123;&#125; _List_iterator() &#123;&#125; _List_iterator(const iterator&amp; __x) : _List_iterator_base(__x._M_node) &#123;&#125; reference operator*() const &#123; return ((_Node*) _M_node)-&gt;_M_data; &#125;#ifndef __SGI_STL_NO_ARROW_OPERATOR pointer operator-&gt;() const &#123; return &amp;(operator*()); &#125;#endif /* __SGI_STL_NO_ARROW_OPERATOR *///前进 _Self&amp; operator++() &#123; this-&gt;_M_incr(); return *this; &#125; _Self operator++(int) &#123; _Self __tmp = *this; this-&gt;_M_incr(); return __tmp; &#125; //后退 _Self&amp; operator--() &#123; this-&gt;_M_decr(); return *this; &#125; _Self operator--(int) &#123; _Self __tmp = *this; this-&gt;_M_decr(); return __tmp; &#125;&#125;; 可以看出，对运算符的重载依赖于父类的_M_incr()和_M_decr() List 123456789101112131415161718192021222324252627template &lt;class _Tp, class _Alloc&gt;class _List_base &#123;public: typedef _Alloc allocator_type; allocator_type get_allocator() const &#123; return allocator_type(); &#125; _List_base(const allocator_type&amp;) &#123; _M_node = _M_get_node(); _M_node-&gt;_M_next = _M_node; _M_node-&gt;_M_prev = _M_node; &#125; ~_List_base() &#123; clear(); _M_put_node(_M_node); &#125; void clear();protected: typedef simple_alloc&lt;_List_node&lt;_Tp&gt;, _Alloc&gt; _Alloc_type; _List_node&lt;_Tp&gt;* _M_get_node() &#123; return _Alloc_type::allocate(1); &#125; void _M_put_node(_List_node&lt;_Tp&gt;* __p) &#123; _Alloc_type::deallocate(__p, 1); &#125; protected: _List_node&lt;_Tp&gt;* _M_node;//只需要一个指针，便可以表示整个环状双向List&#125;; 然后，在class中基本是对_M_node的操作 12345iterator begin() &#123; return (_Node*)(_M_node-&gt;_M_next); &#125; const_iterator begin() const &#123; return (_Node*)(_M_node-&gt;_M_next); &#125; iterator end() &#123; return _M_node; &#125; const_iterator end() const &#123; return _M_node; &#125; 由上可知，_M_node是最后一个节点，然后前一个是头节点 List对节点的操作 1234void push_front(const _Tp&amp; __x) &#123; insert(begin(), __x); &#125;void push_front() &#123;insert(begin());&#125;void push_back(const _Tp&amp; __x) &#123; insert(end(), __x); &#125;void push_back() &#123;insert(end());&#125; 可以看到，以上操作依赖于insert 12345678iterator insert(iterator __position, const _Tp&amp; __x) &#123; _Node* __tmp = _M_create_node(__x); __tmp-&gt;_M_next = __position._M_node; __tmp-&gt;_M_prev = __position._M_node-&gt;_M_prev; __position._M_node-&gt;_M_prev-&gt;_M_next = __tmp; __position._M_node-&gt;_M_prev = __tmp; return __tmp; &#125;","categories":[],"tags":[{"name":"STL","slug":"STL","permalink":"http://originals-tz.github.io/tags/STL/"}]},{"title":"STL之Deque","slug":"STL_Deque","date":"2018-08-13T16:00:00.000Z","updated":"2018-08-21T02:29:22.283Z","comments":true,"path":"2018/08/14/STL_Deque/","link":"","permalink":"http://originals-tz.github.io/2018/08/14/STL_Deque/","excerpt":"deque是双向开口的，可以在头部插入/删除，也可以在尾部插入/删除，而且都是常数时间的复杂度 而这得益于deque的其结构，deque是由多段线型空间组合而成，可以随时增加一段新的空间并连接起来 因此可以把deque看作是一个链表，而每一个链表节点则是一个数组 虽然deque也提供Random Access Iterator，但是这并不是普通的指针，可以的话尽量使用vector","text":"deque是双向开口的，可以在头部插入/删除，也可以在尾部插入/删除，而且都是常数时间的复杂度 而这得益于deque的其结构，deque是由多段线型空间组合而成，可以随时增加一段新的空间并连接起来 因此可以把deque看作是一个链表，而每一个链表节点则是一个数组 虽然deque也提供Random Access Iterator，但是这并不是普通的指针，可以的话尽量使用vector deque的中控器 deque由于结构并不是真正的线形空间，为了维护其整体连续的假象，并提供随机存取的借口，因此需要使用一块map作为中控器 其中map的每一个元素指向一个节点(一块连续的空间)，我们称这块空间为缓冲区 1234567891011template &lt;class _Tp, class _Alloc&gt;class _Deque_base &#123;protected: _Tp** _M_map; //中控器 size_t _M_map_size; //中控器的容量 iterator _M_start; //缓冲区的头 iterator _M_finish;//缓冲区的尾 iterator begin() &#123; return _M_start; &#125; iterator end() &#123; return _M_finish; &#125;&#125; deque的迭代器 1234567891011121314151617181920212223242526template &lt;class _Tp, class _Ref, class _Ptr&gt;struct _Deque_iterator &#123; _Tp* _M_cur; //指向当前元素 _Tp* _M_first;//当前缓冲区的头 _Tp* _M_last;//当前缓冲区的尾 _Map_pointer _M_node; _Self&amp; operator++() &#123; ++_M_cur; if (_M_cur == _M_last) &#123; _M_set_node(_M_node + 1); _M_cur = _M_first; &#125; return *this; &#125; _Self&amp; operator--() &#123; if (_M_cur == _M_first) &#123; _M_set_node(_M_node - 1); _M_cur = _M_last; &#125; --_M_cur; return *this; &#125; &#125;; 迭代器所进行++和–的操作，需要进行边界判断，判断是否能到达下一个/上一个缓冲区 这个行为依赖于_M_set_node 12345void _M_set_node(_Map_pointer __new_node) &#123; _M_node = __new_node; _M_first = *__new_node; _M_last = _M_first + difference_type(_S_buffer_size()); &#125; deque的内存管理 deque的结构，使其需要管理map以及缓冲区 当新建缓冲区的时候，不仅需要构建一块缓冲区，还要往map中构造一个指针，而这些操作由以下函数完成 1234567891011121314_Tp* _M_allocate_node() &#123; return _M_node_allocator.allocate(__deque_buf_size(sizeof(_Tp))); &#125; void _M_deallocate_node(_Tp* __p) &#123; _M_node_allocator.deallocate(__p, __deque_buf_size(sizeof(_Tp))); &#125; _Tp** _M_allocate_map(size_t __n) &#123; return _M_map_allocator.allocate(__n); &#125; void _M_deallocate_map(_Tp** __p, size_t __n) &#123; _M_map_allocator.deallocate(__p, __n); &#125; 安排deque的结构 123456789101112131415161718192021222324template &lt;class _Tp, class _Alloc&gt;void_Deque_base&lt;_Tp,_Alloc&gt;::_M_initialize_map(size_t __num_elements)&#123; size_t __num_nodes = __num_elements / __deque_buf_size(sizeof(_Tp)) + 1; _M_map_size = max((size_t) _S_initial_map_size, __num_nodes + 2); _M_map = _M_allocate_map(_M_map_size); _Tp** __nstart = _M_map + (_M_map_size - __num_nodes) / 2; _Tp** __nfinish = __nstart + __num_nodes; __STL_TRY &#123; _M_create_nodes(__nstart, __nfinish); &#125; __STL_UNWIND((_M_deallocate_map(_M_map, _M_map_size), _M_map = 0, _M_map_size = 0)); _M_start._M_set_node(__nstart); _M_finish._M_set_node(__nfinish - 1); _M_start._M_cur = _M_start._M_first; _M_finish._M_cur = _M_finish._M_first + __num_elements % __deque_buf_size(sizeof(_Tp));&#125;","categories":[],"tags":[{"name":"STL","slug":"STL","permalink":"http://originals-tz.github.io/tags/STL/"}]},{"title":"STL之Vector","slug":"STL_Vector","date":"2018-08-13T16:00:00.000Z","updated":"2018-08-21T02:29:34.341Z","comments":true,"path":"2018/08/14/STL_Vector/","link":"","permalink":"http://originals-tz.github.io/2018/08/14/STL_Vector/","excerpt":"vector是STL中最常用的序列式容器，vector是动态空间，随着元素的加入，它的内部机制会自行扩充空间以容乃新元素 vector的实现技术，关键在于对大小的控制以及重新配置时的数据移动效率","text":"vector是STL中最常用的序列式容器，vector是动态空间，随着元素的加入，它的内部机制会自行扩充空间以容乃新元素 vector的实现技术，关键在于对大小的控制以及重新配置时的数据移动效率 vector概览 12template &lt;class _Tp, class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) &gt;class vector : protected _Vector_base&lt;_Tp, _Alloc&gt; 可以看到，vector依赖于_Vector_base，其使用的空间配置器_Alloc依赖于stl_config.h中的配置 1234567# ifndef __STL_DEFAULT_ALLOCATOR# ifdef __STL_USE_STD_ALLOCATORS# define __STL_DEFAULT_ALLOCATOR(T) allocator&lt; T &gt;# else# define __STL_DEFAULT_ALLOCATOR(T) alloc# endif# endif vector的迭代器 vector提供的是Random Access Iterator,普通指针就具备这种条件 vector的数据结构 vector使用两个iterator指向头部和尾部，指向尾部的包含指向可用空间的尾部和当前空间的尾部 123_Tp* _M_start;_Tp* _M_finish; //当前空间的尾部_Tp* _M_end_of_storage; //可用空间的尾部 下面给出的begin和end获取的迭代器就是以上定义的指针 1234iterator begin() &#123; return _M_start; &#125;const_iterator begin() const &#123; return _M_start; &#125;iterator end() &#123; return _M_finish; &#125;const_iterator end() const &#123; return _M_finish; &#125; 对于_M_end_of_storage,则是判断是否需要重新分配内存的依据 12345678void push_back(const _Tp&amp; __x) &#123; if (_M_finish != _M_end_of_storage) &#123; //是否有可用空间 construct(_M_finish, __x); //在_M_finish所指向的位置上构造__x ++_M_finish; &#125; else _M_insert_aux(end(), __x);//无可用空间，进入处理函数 &#125; vector的空间管理 如果无可用空间，就会交给_M_insert_aux处理 1234567891011121314151617181920212223242526272829303132333435template &lt;class _Tp, class _Alloc&gt;void vector&lt;_Tp, _Alloc&gt;::_M_insert_aux(iterator __position, const _Tp&amp; __x)&#123; if (_M_finish != _M_end_of_storage) &#123; construct(_M_finish, *(_M_finish - 1));//在备用空间起始处构造一个元素，初值为最后一个元素 ++_M_finish; //调整位置 _Tp __x_copy = __x; //将新值赋于构造的元素 copy_backward(__position, _M_finish - 2, _M_finish - 1); *__position = __x_copy; &#125; else &#123; const size_type __old_size = size(); //获取大小 const size_type __len = __old_size != 0 ? 2 * __old_size : 1; //如果vector为空，则配置一个元素大小的空间，如果不为空，就配置两倍于旧vector大小的空间 iterator __new_start = _M_allocate(__len); iterator __new_finish = __new_start; __STL_TRY &#123; //尝试拷贝 __new_finish = uninitialized_copy(_M_start, __position, __new_start); construct(__new_finish, __x); ++__new_finish; __new_finish = uninitialized_copy(__position, _M_finish, __new_finish); &#125; //失败则析构释放新的空间 __STL_UNWIND((destroy(__new_start,__new_finish), _M_deallocate(__new_start,__len))); //析构释放原有空间 destroy(begin(), end()); _M_deallocate(_M_start, _M_end_of_storage - _M_start); _M_start = __new_start; _M_finish = __new_finish; _M_end_of_storage = __new_start + __len; &#125;&#125; 从上面可以看出，所谓的动态分配不过是再次申请，因此对于vector的操作，一旦引起重新分配，iterator就会失效 vector的元素操作 12345678910111213141516171819202122232425void pop_back() &#123; --_M_finish; destroy(_M_finish); &#125;iterator erase(iterator __position) &#123; if (__position + 1 != end()) copy(__position + 1, _M_finish, __position); --_M_finish; destroy(_M_finish); return __position;&#125;iterator erase(iterator __first, iterator __last) &#123; iterator __i = copy(__last, _M_finish, __first); destroy(__i, _M_finish); _M_finish = _M_finish - (__last - __first); return __first;&#125;void resize(size_type __new_size, const _Tp&amp; __x) &#123; if (__new_size &lt; size()) erase(begin() + __new_size, end()); else insert(end(), __new_size - size(), __x);&#125;void resize(size_type __new_size) &#123; resize(__new_size, _Tp()); &#125;void clear() &#123; erase(begin(), end()); &#125; 以上的都是比较简单的元素操作，大抵是进行拷贝，析构，调整边界之类的 不过insert就会比较复杂 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859void insert (iterator __pos, size_type __n, const _Tp&amp; __x) &#123; _M_fill_insert(__pos, __n, __x); &#125; //批量插入template &lt;class _Tp, class _Alloc&gt;void vector&lt;_Tp, _Alloc&gt;::_M_fill_insert(iterator __position, size_type __n, const _Tp&amp; __x)&#123; if (__n != 0) &#123; //检查空间够不够 if (size_type(_M_end_of_storage - _M_finish) &gt;= __n) &#123; _Tp __x_copy = __x; const size_type __elems_after = _M_finish - __position; //计算插入位置后面的元素个数 iterator __old_finish = _M_finish; //插入点后面的元素少于新增的元素，也就是插入点到尾部的容量能够容纳新元素 if (__elems_after &gt; __n) &#123; //将当前元素拷贝到后面 uninitialized_copy(_M_finish - __n, _M_finish, _M_finish); _M_finish += __n; //将新元素复制到空出来的空间上 copy_backward(__position, __old_finish - __n, __old_finish); fill(__position, __position + __n, __x_copy); &#125; else &#123; //插入点到尾部的容量不能容纳新元素 //构建部分新元素 uninitialized_fill_n(_M_finish, __n - __elems_after, __x_copy); _M_finish += __n - __elems_after; //复制旧的元素 uninitialized_copy(__position, __old_finish, _M_finish); _M_finish += __elems_after; //构建剩余的元素 fill(__position, __old_finish, __x_copy); &#125; &#125; else &#123; const size_type __old_size = size(); const size_type __len = __old_size + max(__old_size, __n); //尝试获得空间然后构造 iterator __new_start = _M_allocate(__len); iterator __new_finish = __new_start; __STL_TRY &#123; __new_finish = uninitialized_copy(_M_start, __position, __new_start); //填充新元素 __new_finish = uninitialized_fill_n(__new_finish, __n, __x); __new_finish = uninitialized_copy(__position, _M_finish, __new_finish); &#125; //失败则析构释放所有新的空间 __STL_UNWIND((destroy(__new_start,__new_finish), _M_deallocate(__new_start,__len))); //析构释放旧的空间 destroy(_M_start, _M_finish); _M_deallocate(_M_start, _M_end_of_storage - _M_start); _M_start = __new_start; _M_finish = __new_finish; _M_end_of_storage = __new_start + __len; &#125; &#125;&#125;","categories":[],"tags":[{"name":"STL","slug":"STL","permalink":"http://originals-tz.github.io/tags/STL/"}]},{"title":"cmake学习笔记-1","slug":"CMake","date":"2018-08-08T16:00:00.000Z","updated":"2018-08-21T02:27:20.785Z","comments":true,"path":"2018/08/09/CMake/","link":"","permalink":"http://originals-tz.github.io/2018/08/09/CMake/","excerpt":"因为Clion是用cmake来构建工程的，特地学一些简单的东西","text":"因为Clion是用cmake来构建工程的，特地学一些简单的东西 基本操作 对于一个工程，首先要设置 cmake版本 工程名 c++的标准 123cmake_minimum_required(VERSION 3.8)project(Fat32)set(CMAKE_CXX_STANDARD 11) 然后，配置源文件的路径，可以将源文件设置成一个变量，然后生成可执行文件 12345678910111213#配置单个或者多个set(Source ./source.cpp)set(Source ./source1.cpp ./source2.cpp)#配置整个文件夹中的源文件aux_source_directory(./source Source)#如果需要，可以链接库，例如gtest，pthread等等，这些库必须是能在环境变量中搜的到的，也就是可以直接-l[lib]LINK_LIBRARIES(gtest)LINK_LIBRARIES(gtest_main)LINK_LIBRARIES(pthread)#如果需要，可以设置可执行文件输出的路径set(CMAKE_RUNTIME_OUTPUT_DIRECTORY [path])#生成可执行文件add_executable(Exec $&#123;Source&#125;) option和configure_file 有时候我们需要自定义编译，这时可以设置option和configure_file 注意，option和缓存相关，上次的结果会影响下次的默认设置，完全自定义需要手动设置所有的option 1234config.h.in:#cmakedefine PYTHON2#cmakedefine ATUO 1234567option(AUTO \"choose the version of python automatically\" ON)option(PYTHON2 \"version python2\" OFF)#将config.h.in的内容设置好后覆盖config.h,然后再编译configure_file( \"config.h.in\" \"$&#123;PROJECT_SOURCE_DIR&#125;/src/config.h\") 链接动态库 详细 cmake支持某些库，具体可以使用cmake --help-module-list查看 如果是支持的模块，可以使用find_package()查找，然后一些变量会被设置 12345&lt;NAME&gt;_VERSION_STRING //版本&lt;NAME&gt;_FOUND //是否找到&lt;NAME&gt;_INCLUDE_DIRS or &lt;NAME&gt;_INCLUDES //头文件的路径&lt;NAME&gt;_LIBRARIES or &lt;NAME&gt;_LIBRARIES or &lt;NAME&gt;_LIBS //lib的路径&lt;NAME&gt;_DEFINITIONS 1234find_package(PythonLibs)#链接add_executable(target .....)target_link_libraries(target $&#123;PYTHON_LIBRARIES&#125;) 字符串替换 我们可以操作字符串变量，进行匹配，替换 123string( REPLACE \".cpp\" \"\" testname $&#123;testsourcefile&#125;) //一般替换string( REGEX REPLACE \"(.[1-9]).*\" \"\" version $&#123;PYTHONLIBS_VERSION_STRING&#125; ) //正则替换string(替换模式 替换字符串 目标字符串 输出字符串 输入字符串) IF 1234567891011121314151617181920212223242526if()else()endif()#例如if(AUTO) if(version STREQUAL 2) MESSAGE(\"choose python2 automatically\") set(PYTHON2 ON) else() MESSAGE(\"choose python3 automatically\") set(PYTHON2 OFF) endif()else() if(PYTHON2) if(NOT (version STREQUAL 2)) #if you use python2.x, set the include_dir and libraries_dir #you can use \"find / -name \"libpython2*\" \" to get the path of your lib set(PYTHON_INCLUDE_DIRS /usr/include/python2.7) set(PYTHON_LIBRARIES /usr/lib/libpython2.7.dylib) endif() MESSAGE(\"choose python 2\") else() MESSAGE(\"choose python 3\") endif()endif() 具体例子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546cmake_minimum_required(VERSION 3.11)project(PythonCaller)set(CMAKE_CXX_STANDARD 11)find_package(PythonLibs)aux_source_directory(./test/version_test VersionTest)MESSAGE($&#123;PYTHON_INCLUDE_DIRS&#125;)#get the version of python, format : [2-3].*, use the regex \"(.[1-9]).*\"STRING( REGEX REPLACE \"(.[1-9]).*\" \"\" version $&#123;PYTHONLIBS_VERSION_STRING&#125; )MESSAGE(\"Defalut : Python3\")option(AUTO \"choose the version of python automatically\" ON)option(PYTHON2 \"version python2\" OFF)if(AUTO) if(version STREQUAL 2) MESSAGE(\"choose python2 automatically\") set(PYTHON2 ON) else() MESSAGE(\"choose python3 automatically\") set(PYTHON2 OFF) endif()else() if(PYTHON2) if(NOT (version STREQUAL 2)) #if you use python2.x, set the include_dir and libraries_dir #you can use \"find / -name \"libpython2*\" \" to get the path of your lib set(PYTHON_INCLUDE_DIRS /usr/include/python2.7) set(PYTHON_LIBRARIES /usr/lib/libpython2.7.dylib) endif() MESSAGE(\"choose python 2\") else() MESSAGE(\"choose python 3\") endif()endif()configure_file( \"config.h.in\" \"$&#123;PROJECT_SOURCE_DIR&#125;/src/config.h\")include_directories($&#123;PYTHON_INCLUDE_DIRS&#125;)add_executable(version_test $&#123;VersionTest&#125;)target_link_libraries(version_test $&#123;PYTHON_LIBRARIES&#125;) 123456789101112131415161718192021222324252627282930313233343536373839404142#Project Settingcmake_minimum_required(VERSION 3.8)project(Fat32)set(CMAKE_CXX_STANDARD 11)LINK_LIBRARIES(gtest)LINK_LIBRARIES(gtest_main)LINK_LIBRARIES(pthread)#Path Settingaux_source_directory(./VFS MAIN)aux_source_directory(./UnitTesting TEST)set(FATLIB FAT/fat.cpp)link_directories(./cmake-build-debug)#Generate dymanic Libraryadd_library(fat SHARED $&#123;FATLIB&#125;)#Generate Unit Test#set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ./unit_test)#add_executable(UnitTest $&#123;TEST&#125; $&#123;FATLIB&#125;)#Generate Mainset(CMAKE_RUNTIME_OUTPUT_DIRECTORY ./terminal)add_executable(Terminal $&#123;MAIN&#125;)target_link_libraries(Terminal libfat.dylib)#Generate Commandsaux_source_directory(./cmd CMD)set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ./bin)foreach( testsourcefile $&#123;CMD&#125; ) string( REPLACE \".cpp\" \"\" testname $&#123;testsourcefile&#125;) string( REPLACE \"./cmd/\" \"\" testname $&#123;testname&#125;) MESSAGE($&#123;testname&#125;) add_executable($&#123;testname&#125; $&#123;testsourcefile&#125;) target_link_libraries($&#123;testname&#125; libfat.dylib)endforeach( testsourcefile $&#123;CMD&#125;)aux_source_directory(./tinyEditor editor)add_executable(edit ./tinyEditor/editor.cpp ./tinyEditor/main.cpp ./tinyEditor/fat32_editor.cpp ./FAT/fat.cpp)","categories":[],"tags":[{"name":"other","slug":"other","permalink":"http://originals-tz.github.io/tags/other/"}]},{"title":"C++ 模版编程","slug":"C++TemplatePractice1","date":"2018-08-08T16:00:00.000Z","updated":"2018-08-21T02:27:12.907Z","comments":true,"path":"2018/08/09/C++TemplatePractice1/","link":"","permalink":"http://originals-tz.github.io/2018/08/09/C++TemplatePractice1/","excerpt":"最近在写一个C++调用Python的库，可以说把我所学到的关于模版的知识都用上了 真的是，用起来越简单的东西，做起来就越难","text":"最近在写一个C++调用Python的库，可以说把我所学到的关于模版的知识都用上了 真的是，用起来越简单的东西，做起来就越难 1.不定参数 为了方便，我想写一个能够传入任意数量和类型参数的函数，而且能够根据不同的类型进行映射 首先，为了解决映射，我们可以实现设置好映射，然后利用模版的特化，根据传入的类型的到正确的特化模版 然后在特化模版中存储着类型映射信息，例如，如果是int，就映射字符串i 123456789101112131415template&lt;typename T&gt;struct type_tratis &#123; std::string flag = \"null\";&#125;;template&lt;&gt;struct type_tratis&lt;int&gt; &#123; std::string flag = \"i\";&#125;;int main() &#123; type_traits&lt;int&gt; s; std::cout &lt;&lt; s.flag &lt;&lt; std::endl; return 0;&#125; 然后，我要传入不定类型和数量的参数，可以使用不定参数模版 这个模版可以包含一个参数包，然后可以通过递归匹配层层展开 12345678910template&lt;typename T&gt;void PythonLoader::ParseType(int count, T t) &#123; //包的最后一个&#125;template&lt;typename T, typename... Args&gt;void PythonLoader::ParseType(T t, Args... args) &#123; //解包 ParseType(args...);&#125; 这样，大抵完成了第一个目标 2.推断传入的tuple类型，然后赋予正确的值 12345678910111213141516171819202122template&lt;class Tuple, std::size_t N&gt;struct TuplePrinter &#123; static void print(const Tuple&amp; t) &#123; TuplePrinter&lt;Tuple, N - 1&gt;::print(t); std::cout &lt;&lt; \", \" &lt;&lt; std::get&lt;N - 1&gt;(t); &#125;&#125;;template&lt;class Tuple&gt;struct TuplePrinter&lt;Tuple, 1&gt;&#123; static void print(const Tuple&amp; t) &#123; std::cout &lt;&lt; std::get&lt;0&gt;(t); &#125;&#125;;template&lt;class... Args&gt;void PrintTuple(const std::tuple&lt;Args...&gt;&amp; t)&#123; TuplePrinter&lt;decltype(t), sizeof...(Args)&gt;::print(t);&#125; 使用这个方法是因为std::get&lt;&gt;只能接受``constant expression` 于是就利用模版元编程达到遍历tuple中每一个变量的效果 对于每一个变量，我们可以这样获得它的原始类型 1typedef typename std::tuple_element&lt;N - 1, typename std::remove_reference&lt;decltype(t)&gt;::type&gt;::type ValueType; 其实也就是利用 std::tuple_element&lt;pos, [types]&gt;::type 首先对于传入的一个tuple&lt;int, int&gt; i，如果直接放到[types]是行不通的，必须要获得类型数组[int,int] 所以直接获得dectyple(i)获得带引用的类型数组，然后用std::remove_reference&lt;&gt;::type获取原始类型数组，然后就能使用std::tuple_element&lt;&gt;::type获取某一个位置的原本类型了 可喜可贺可喜可贺 3.总结 虽然看起来也不是很难，但是充分说明了我的练习量还不够，在调试模版的时候花了很多时间 不过从中也慢慢摸清了模版的特性，模版的关键无它，唯类型推断与匹配","categories":[],"tags":[{"name":"template","slug":"template","permalink":"http://originals-tz.github.io/tags/template/"}]},{"title":"STL Allocator","slug":"STL_Allocator","date":"2018-08-05T16:00:00.000Z","updated":"2018-08-21T02:29:18.385Z","comments":true,"path":"2018/08/06/STL_Allocator/","link":"","permalink":"http://originals-tz.github.io/2018/08/06/STL_Allocator/","excerpt":"前言 在c++中，可以使用new在堆上构建一个新的对象，其实new包含两个步骤 分配内存 使用constructor在内存中构建对象内容 而delete也是如此 调用deconstructor将对象析构 释放内存 知道了new和delete的原理，可以手动模拟一下","text":"前言 在c++中，可以使用new在堆上构建一个新的对象，其实new包含两个步骤 分配内存 使用constructor在内存中构建对象内容 而delete也是如此 调用deconstructor将对象析构 释放内存 知道了new和delete的原理，可以手动模拟一下 123456789101112class Test &#123;public: Test(int i) &#123;&#125;;&#125;;int main() &#123; Test *k = (Test *) malloc (sizeof(Test)); //分配内存 new (k) Test(3); //构建对象 ，placement new(placement有放置的意思，可以理解为将对象内容放置在内存中) k-&gt;~k(); //析构 free(k); //释放内存 return 0;&#125; STL中的空间配置器 在STL中，为了妥善地管理内存，有专门的STL allocator，这个是为STL中的各种容器服务的 然后关于分配内存和构造STL allocator决定将这两个阶段分开，内存配置器定义在&lt;memory&gt;之中，&lt;memory&gt;包含 &lt;stl_alloc.h&gt; : 负责内存分配 &lt;stl_construct.h&gt; : 负责对象构造，析构 &lt;stl_uninitialized.h&gt; : 常用的工具 stl_construct.h 如上提到的，此头文件包含的函数负责对象的构造与析构 123456789101112131415161718192021//构造template &lt;class _T1, class _T2&gt;inline void construct(_T1* __p, const _T2&amp; __value) &#123; _Construct(__p, __value);&#125;template &lt;class _T1&gt;inline void construct(_T1* __p) &#123; _Construct(__p);&#125;//析构template &lt;class _Tp&gt;inline void destroy(_Tp* __pointer) &#123; _Destroy(__pointer);&#125;//批量析构template &lt;class _ForwardIterator&gt;inline void destroy(_ForwardIterator __first, _ForwardIterator __last) &#123; _Destroy(__first, __last);&#125; 构造 12345678inline void _Construct(_T1* __p, const _T2&amp; __value) &#123; new ((void*) __p) _T1(__value); &#125;template &lt;class _T1&gt;inline void _Construct(_T1* __p) &#123; new ((void*) __p) _T1();&#125; 可以看到，使用的都是placement new,和上文我们所做的一样，那么构造函数是用在哪里的呢？答案是用在STL容器里面的，例如vector的push_back里就有 12345678void push_back(const _Tp&amp; __x) &#123; if (_M_finish != _M_end_of_storage) &#123; construct(_M_finish, __x); //_M_finish是指向尾端的指针，__x就是要放入的值 ++_M_finish; &#125; else _M_insert_aux(end(), __x); &#125; 析构 想象一下，如何对vector中的内容进行析构 首先，要给出范围 【1】，传入first和last两个Iterator,假设类型是vector&lt;Test&gt;::iterator=Test* 12345678910111213141516171819202122template &lt;class _ForwardIterator&gt;inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last) &#123; __destroy(__first, __last, //【1】 __VALUE_TYPE(__first)); //【2】&#125;------------------------------value_type//【3】template &lt;class _Iter&gt;inline typename iterator_traits&lt;_Iter&gt;::value_type*__value_type(const _Iter&amp;)//【4】&#123; return static_cast&lt;typename iterator_traits&lt;_Iter&gt;::value_type*&gt;(0);//【5】&#125;------------------------------Iter_tarits//【6】template &lt;class _Tp&gt;struct iterator_traits&lt;_Tp*&gt; &#123; typedef random_access_iterator_tag iterator_category; typedef _Tp value_type; typedef ptrdiff_t difference_type; typedef _Tp* pointer; typedef _Tp&amp; reference;&#125;; 可以看到上面的函数对迭代器进行【2】VALUE_TYPE(__value_type的宏)取value_type, __value_type如【3】所示，此时，【4】_Iter = Test * 然后对其进行【5】iterator_traits，匹配到【6】的特化版本，返回的value_type是Test 然后对其进行【7】type_traits看看有没有trivial（无用的，可忽略的）析构函数 type_traits只对POD类型进行了特化，因此Test匹配到了泛化版本，如【8】所示 123456789101112131415161718template &lt;class _ForwardIterator, class _Tp&gt;inline void __destroy(_ForwardIterator __first, _ForwardIterator __last, _Tp*)&#123; typedef typename __type_traits&lt;_Tp&gt;::has_trivial_destructor _Trivial_destructor;//【7】 __destroy_aux(__first, __last, _Trivial_destructor());&#125;----------------------------------------------type_traits//【8】template &lt;class _Tp&gt;struct __type_traits &#123; typedef __true_type this_dummy_member_must_be_first; typedef __false_type has_trivial_default_constructor; typedef __false_type has_trivial_copy_constructor; typedef __false_type has_trivial_assignment_operator; typedef __false_type has_trivial_destructor; typedef __false_type is_POD_type;&#125;; 可以看到，STL取最保守的值，也就是说，除非有特化，不然都会认为构造函数是no-trivial(重要的) 例如Test *没有经过特化，那么得到的结果就是has_trivial_destructor = __false_type 然后，就会开始选择析构的方式 123456789101112131415161718192021template &lt;class _ForwardIterator&gt;void__destroy_aux(_ForwardIterator __first, _ForwardIterator __last, __false_type) //有重要的析构函数，调用，Test选择的是这个&#123; for ( ; __first != __last; ++__first) destroy(&amp;*__first);&#125;template &lt;class _ForwardIterator&gt; inline void __destroy_aux(_ForwardIterator, _ForwardIterator, __true_type) &#123;&#125; //析构函数是不重要的，所以不调用//开始析构 template &lt;class _Tp&gt;inline void destroy(_Tp* __pointer) &#123; _Destroy(__pointer);&#125;template &lt;class _Tp&gt;inline void _Destroy(_Tp* __pointer) &#123; __pointer-&gt;~_Tp();&#125; std_alloc.h 此文件包含内存的配置与释放，设计如下 向system heap索取空间 考虑多线程状态 考虑内存不足的应变措施 考虑内存碎片问题 以下讨论排除多线程状态 SGI以malloc和free完成内存的配置和释放，但是考虑到内存碎片问题，SGI设计了双层配置器 一级配置器使用malloc和free 二级配置器使用复杂的内存池 当申请内存超过128byte，使用一级配置器，小于则使用二级配置器，然而整个设计是否采用二级配置器，取决于__USE_MALLOC具体可以看下面，展示了什么情况使用二级配置器 12345678910---------stl_alloc.h#ifdef __STL_STATIC_TEMPLATE_MEMBER_BUG# define __USE_MALLOC //使用二级配置器#endif---------stl_config.h# ifdef __GNUC__ //gcc的版本# if __GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &lt;= 7# define __STL_STATIC_TEMPLATE_MEMBER_BUG# endif# endif 一级配置器 一级配置器为template &lt;int __inst&gt; class __malloc_alloc_template 首先定义所抛出的异常bad_alloc 12345678910#ifndef __THROW_BAD_ALLOC# if defined(__STL_NO_BAD_ALLOC) || !defined(__STL_USE_EXCEPTIONS)# include &lt;stdio.h&gt;# include &lt;stdlib.h&gt;# define __THROW_BAD_ALLOC fprintf(stderr, \"out of memory\\n\"); exit(1)# else /* Standard conforming out-of-memory handling */# include &lt;new&gt;# define __THROW_BAD_ALLOC throw std::bad_alloc()# endif#endif 然后是分配和释放的接口 123456789101112131415161718static void* allocate(size_t __n)&#123; void* __result = malloc(__n); //分配内存 if (0 == __result) __result = _S_oom_malloc(__n); //失败则调用处理内存不足的函数 return __result;&#125;static void deallocate(void* __p, size_t /* __n */)&#123; free(__p);&#125;static void* reallocate(void* __p, size_t /* old_sz */, size_t __new_sz)&#123; void* __result = realloc(__p, __new_sz); //更改已经配置的内存空间，即更改由malloc()函数分配的内存空间的大小。 if (0 == __result) __result = _S_oom_realloc(__p, __new_sz);//失败则调用 return __result;&#125; 下面是处理失败的函数，当然你也可以自己指定处理方式 123456static void (* __set_malloc_handler(void (*__f)()))() &#123; void (* __old)() = __malloc_alloc_oom_handler; __malloc_alloc_oom_handler = __f; //设置处理函数，默认为0 return(__old); &#125; 默认的处理方式 1234567891011121314151617181920212223242526272829303132template &lt;int __inst&gt;void*__malloc_alloc_template&lt;__inst&gt;::_S_oom_malloc(size_t __n)&#123; void (* __my_malloc_handler)(); void* __result; for (;;) &#123; __my_malloc_handler = __malloc_alloc_oom_handler; //尝试获得处理函数 if (0 == __my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125; //如果没有就抛出异常 (*__my_malloc_handler)(); //调用处理函数 __result = malloc(__n); //再次分配 if (__result) return(__result); //如果分配成功则结束，否则继续调用处理函数 &#125;&#125;template &lt;int __inst&gt;void* __malloc_alloc_template&lt;__inst&gt;::_S_oom_realloc(void* __p, size_t __n)&#123; void (* __my_malloc_handler)(); void* __result; for (;;) &#123; __my_malloc_handler = __malloc_alloc_oom_handler; //尝试获取处理函数 if (0 == __my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125; //抛出异常 (*__my_malloc_handler)(); __result = realloc(__p, __n); if (__result) return(__result); &#125;&#125;typedef __malloc_alloc_template&lt;0&gt; malloc_alloc; //定义一级配置器 也就是说，默认内存不够就会抛出异常，当然如果你设置了处理函数，就会用处理函数去处理 设计内存不足的处理方式是你的责任 二级配置器 二级配置器为 template &lt;bool threads, int inst&gt;class __default_alloc_template 二级配置器使用内存池，每次配置一大块内存，然后将其分成分成16个链表，各自管理的大小为8的倍数 也就是说每一个链表管理一种大小的内存块，16个链表管理{8,16,…,128}byte的小型内存块链 123enum &#123;_ALIGN = 8&#125;;enum &#123;_MAX_BYTES = 128&#125;;enum &#123;_NFREELISTS = 16&#125;; // _MAX_BYTES/_ALIGN 其中内存块链的节点为_Obj_，链表采用线性表+链表的方式管理，其中链的初始化为 1&#123;0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, &#125;; 12345union _Obj &#123; union _Obj* _M_free_list_link; char _M_client_data[1]; /* The client sees this. */ &#125;;static _Obj* __STL_VOLATILE _S_free_list[_NFREELISTS]; 根据索取的内存块大小决定从哪一条链上索取内存块 例如索取128byte的块，则定位到 index = (128+7)/8 - 1 = 15的链 123static size_t _S_freelist_index(size_t __bytes) &#123; return (((__bytes) + (size_t)_ALIGN-1)/(size_t)_ALIGN - 1); &#125; 关于内存池的管理 12345678910// 发现链上没有可用块，就重新填充 static void* _S_refill(size_t __n);//配置一大块空间，能够容纳nodejs个大小为size的内存块//如果失败，则会减少索要的个数，也就是nodjs static char* _S_chunk_alloc(size_t __size, int&amp; __nobjs); // 内存池的状态 static char* _S_start_free; static char* _S_end_free; static size_t _S_heap_size; 内存配置函数 12345678910111213141516171819202122232425262728293031323334353637static void* allocate(size_t __n) &#123; void* __ret = 0; if (__n &gt; (size_t) _MAX_BYTES) &#123; //大于128就使用一级配置器 __ret = malloc_alloc::allocate(__n); &#125; else &#123; _Obj* __STL_VOLATILE* __my_free_list = _S_free_list + _S_freelist_index(__n); //找到合适的内存链 _Obj* __RESTRICT __result = *__my_free_list; if (__result == 0) //如果该链上无任何内存块 __ret = _S_refill(_S_round_up(__n)); //重新填充，并返回一个块 else &#123; *__my_free_list = __result -&gt; _M_free_list_link; __ret = __result; &#125; &#125; return __ret; &#125;;static void deallocate(void* __p, size_t __n) //将内存块回收到对应的链表上 &#123; if (__n &gt; (size_t) _MAX_BYTES) malloc_alloc::deallocate(__p, __n); //直接释放 else &#123; //回收 _Obj* __STL_VOLATILE* __my_free_list = _S_free_list + _S_freelist_index(__n); _Obj* __q = (_Obj*)__p; __q -&gt; _M_free_list_link = *__my_free_list; *__my_free_list = __q; // lock is released here &#125; &#125; 重新填充 如果在分配的时候发现链上没有可用块了，就调用该函数重现填充链表 默认填充的数目是20，如果内存池内存不够，那么获得的块少于20 123456789101112131415161718192021222324252627282930313233template &lt;bool __threads, int __inst&gt;void*__default_alloc_template&lt;__threads, __inst&gt;::_S_refill(size_t __n)&#123; int __nobjs = 20; //默认填充数量 char* __chunk = _S_chunk_alloc(__n, __nobjs); //从内存池取得空间，__nodejs是引用传递，其值会在_S_chunk_alloc中会被改变 _Obj* __STL_VOLATILE* __my_free_list; _Obj* __result; _Obj* __current_obj; _Obj* __next_obj; int __i; if (1 == __nobjs) return(__chunk); //只能获得一个节点就直接返回给使用者 __my_free_list = _S_free_list + _S_freelist_index(__n); //获得相应的链表，准备开始填充 /* Build free list in chunk */ __result = (_Obj*)__chunk; //在chunk上建立链表 *__my_free_list = __next_obj = (_Obj*)(__chunk + __n); //指向链表尾部 for (__i = 1; ; __i++) &#123; //从1开始逐渐填充，第0个返回给使用者 __current_obj = __next_obj; __next_obj = (_Obj*)((char*)__next_obj + __n); if (__nobjs - 1 == __i) &#123; __current_obj -&gt; _M_free_list_link = 0; break; &#125; else &#123; __current_obj -&gt; _M_free_list_link = __next_obj; &#125; &#125; return(__result);&#125; 内存池 _S_chunk_alloc是从内存池中获取空间交给free list 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778template &lt;bool __threads, int __inst&gt;char*__default_alloc_template&lt;__threads, __inst&gt;::_S_chunk_alloc(size_t __size, int&amp; __nobjs)&#123; char* __result; size_t __total_bytes = __size * __nobjs; //计算索取内存块的总大小 size_t __bytes_left = _S_end_free - _S_start_free; //计算内存池剩余量 if (__bytes_left &gt;= __total_bytes) &#123; //剩余容量满足索取量。直接返回内存池的起始端指针 __result = _S_start_free; _S_start_free += __total_bytes;//调整内存池 return(__result); &#125; else if (__bytes_left &gt;= __size) &#123; //如果总量不够，判断是否能够返回一块内存块 //如果可以 __nobjs = (int)(__bytes_left/__size);//改变__nodejs __total_bytes = __size * __nobjs;//改变剩余容量 __result = _S_start_free;//准备块的地址 _S_start_free += __total_bytes;//调整内存池 return(__result); &#125; else &#123; //如果连一个块都不能获取，则尝试将剩余的空间都放到对应的链表上 //然后重新填充内存池 size_t __bytes_to_get = 2 * __total_bytes + _S_round_up(_S_heap_size &gt;&gt; 4); //计算即将填充的容量，新容量为当前需求量的两倍，并且附加一个随配置次数增大的附加值 // Try to make use of the left-over piece.充分利用剩余资源 if (__bytes_left &gt; 0) &#123; _Obj* __STL_VOLATILE* __my_free_list = _S_free_list + _S_freelist_index(__bytes_left); ((_Obj*)_S_start_free) -&gt; _M_free_list_link = *__my_free_list; *__my_free_list = (_Obj*)_S_start_free; &#125; //重新获取一大块内存 _S_start_free = (char*)malloc(__bytes_to_get); if (0 == _S_start_free) &#123; size_t __i; _Obj* __STL_VOLATILE* __my_free_list; _Obj* __p; // Try to make do with what we have. That can't // hurt. We do not try smaller requests, since that tends // to result in disaster on multi-process machines. //遍历16个链表 for (__i = __size; __i &lt;= (size_t) _MAX_BYTES; __i += (size_t) _ALIGN) &#123; __my_free_list = _S_free_list + _S_freelist_index(__i); __p = *__my_free_list; if (0 != __p) //如果链上有剩余空间，将其调入内存池 &#123; *__my_free_list = __p -&gt; _M_free_list_link; //调整内存池，重新分配 _S_start_free = (char*)__p; _S_end_free = _S_start_free + __i; return(_S_chunk_alloc(__size, __nobjs)); // Any leftover piece will eventually make it to the // right free list. &#125; &#125; _S_end_free = 0; // In case of exception. 如果真的没有内存了 _S_start_free = (char*)malloc_alloc::allocate(__bytes_to_get); //尝试使用第一配置器，实在不行就抛出异常，分配结束 // This should either throw an // exception or remedy the situation. Thus we assume it // succeeded. &#125; //看来第一配置器找到内存了，调整一下内存池 _S_heap_size += __bytes_to_get; _S_end_free = _S_start_free + __bytes_to_get; return(_S_chunk_alloc(__size, __nobjs)); &#125;&#125; stl_uninitialized 这里有三个用于为初始化的空间的函数 三者都有一个特点，就是如果过程中产生一次失败(会抛出异常)，则将之前所做的全部撤销 具体是使用 1define __STL_UNWIND(action) catch(...) &#123; action; throw; &#125; 该宏捕获所有异常，并执行action uninitialized_copy 可以将某个范围的对象拷贝到未初始化的内存，如果拷贝存在一次失败，那么就不构造任何东西 123456789101112131415161718192021222324252627282930313233343536373839404142//参数模式类似于前面提到过的析构，同样是去value typetemplate &lt;class _InputIter, class _ForwardIter&gt;inline _ForwardIter uninitialized_copy(_InputIter __first, _InputIter __last, _ForwardIter __result)&#123; return __uninitialized_copy(__first, __last, __result, __VALUE_TYPE(__result)); //根据value type选择合适的复制函数&#125;template &lt;class _InputIter, class _ForwardIter, class _Tp&gt;inline _ForwardIter__uninitialized_copy(_InputIter __first, _InputIter __last, _ForwardIter __result, _Tp*)&#123; typedef typename __type_traits&lt;_Tp&gt;::is_POD_type _Is_POD; //又出现了，判断是否是POD类型 return __uninitialized_copy_aux(__first, __last, __result, _Is_POD());&#125;template &lt;class _InputIter, class _ForwardIter&gt;inline _ForwardIter __uninitialized_copy_aux(_InputIter __first, _InputIter __last, _ForwardIter __result, __true_type) //如果是POD类型，就不需要特地调用构造函数&#123; return copy(__first, __last, __result); //调用算法库的copy&#125;template &lt;class _InputIter, class _ForwardIter&gt;_ForwardIter __uninitialized_copy_aux(_InputIter __first, _InputIter __last, _ForwardIter __result, __false_type) //如果不是POD，则逐个调用构造函数&#123; _ForwardIter __cur = __result; __STL_TRY &#123; for ( ; __first != __last; ++__first, ++__cur) _Construct(&amp;*__cur, *__first); return __cur; &#125; __STL_UNWIND(_Destroy(__result, __cur)); //捕获异常并将所有已构造的对象全部析构&#125; 两个特化版本，const char , const wchar_t，对于这两个类型，最有效的方法是直接移动内存内容，使用memmove 1234567891011121314inline char* uninitialized_copy(const char* __first, const char* __last, char* __result) &#123; memmove(__result, __first, __last - __first); return __result + (__last - __first);&#125;inline wchar_t* uninitialized_copy(const wchar_t* __first, const wchar_t* __last, wchar_t* __result)&#123; memmove(__result, __first, sizeof(wchar_t) * (__last - __first)); return __result + (__last - __first);&#125; uninitialized_fill 该函数的作用是将某个范围的内存初始化为某个值 12345678910111213141516171819202122232425262728293031323334353637template &lt;class _ForwardIter, class _Tp&gt;inline void uninitialized_fill(_ForwardIter __first, _ForwardIter __last, const _Tp&amp; __x)&#123; __uninitialized_fill(__first, __last, __x, __VALUE_TYPE(__first)); //一样的套路，判断value_type&#125;template &lt;class _ForwardIter, class _Tp, class _Tp1&gt;inline void __uninitialized_fill(_ForwardIter __first, _ForwardIter __last, const _Tp&amp; __x, _Tp1*)&#123; typedef typename __type_traits&lt;_Tp1&gt;::is_POD_type _Is_POD; __uninitialized_fill_aux(__first, __last, __x, _Is_POD());//判断是否是POD类型 &#125;template &lt;class _ForwardIter, class _Tp&gt;inline void__uninitialized_fill_aux(_ForwardIter __first, _ForwardIter __last, const _Tp&amp; __x, __true_type)&#123; fill(__first, __last, __x); //调用算法库&#125;template &lt;class _ForwardIter, class _Tp&gt;void__uninitialized_fill_aux(_ForwardIter __first, _ForwardIter __last, const _Tp&amp; __x, __false_type)&#123; _ForwardIter __cur = __first; __STL_TRY &#123; for ( ; __cur != __last; ++__cur) _Construct(&amp;*__cur, __x); &#125; __STL_UNWIND(_Destroy(__first, __cur));//捕获异常，析构&#125; uninitialized_fill_n 将从[firs,first+n]全部构造为相同的值，和上面的一样 123456template &lt;class _ForwardIter, class _Size, class _Tp&gt;inline _ForwardIter uninitialized_fill_n(_ForwardIter __first, _Size __n, const _Tp&amp; __x)&#123; return __uninitialized_fill_n(__first, __n, __x, __VALUE_TYPE(__first));&#125; 至此 以上大致分析完了内存构造的三个重要的块，真的是累","categories":[],"tags":[{"name":"STL","slug":"STL","permalink":"http://originals-tz.github.io/tags/STL/"}]},{"title":"Configure Vim On Mac","slug":"ConfigureVim","date":"2018-08-03T16:00:00.000Z","updated":"2018-08-21T02:30:18.795Z","comments":true,"path":"2018/08/04/ConfigureVim/","link":"","permalink":"http://originals-tz.github.io/2018/08/04/ConfigureVim/","excerpt":"一直都觉得网上很火的SpaceVim用起来没那么顺手 主要是装的东西太多了，所以最近都在用atom 不过今天突然想卸掉SpaceVim用一下另一个配置spf13-vim，于是有了此文","text":"一直都觉得网上很火的SpaceVim用起来没那么顺手 主要是装的东西太多了，所以最近都在用atom 不过今天突然想卸掉SpaceVim用一下另一个配置spf13-vim，于是有了此文 添加python和lua支持 安装spf13-vim很简单，主要是按照readme所给的方式就能安装成功 但是需要注意的是，vim要有lua和python的支持 在vim中使用:echo has(&quot;lua&quot;)和:echo has(&quot;python&quot;)来查看是否有支持 返回1就是有，0就是没有，那么可以重新安装 在mac中可以用brew info vim查看vim的的依赖 1234==&gt; DependenciesRequired: perl ✔, ruby ✔Recommended: python ✔Optional: gettext ✘, lua ✘, luajit ✔, python@2 ✔ 根据这个就可以知道需要安装什么了，我安装的是luajit和python@2 1brew install --with-luajit --with-python@2 安装完成之后就可以进行下一步，配置自动补全 配置YouCompleteMe link 首先安装完spf13-vim之后，如果发现没有安装YouCompleteMe可以在.vimrc.bundles中添加 1Bundle `Valloric/YouCompleteMe` 这样在vim中输入 1:BundleInstall 就可以安装了 如安装了，那么就可以找到.vim/bundle/YouCompleteMe这个文件夹了 现在我们需要的是为其添加语法支持，首先安装clang-completer 1.vim/bundle/YouCompleteMe/&gt; install.sh --clang-completer 安装完成后要将配置文件复制到根目录下 对于YCM来说，当打开一个代码文件时，插件将顺着文件所在的路径一直向上查找，如果搜索到第一个配置文件将立刻读入 如果一直搜索到根目录依旧无法找到配置文件，语法补全将不被启用。由此可知，文件所在目录的配置文件优先级最高，根目录的优先级最低 其中配置文件在.vim/bundle/YouCompleteMe/third_party/ycmd中，将配置文件vi .ycm_extra_conf.py复制到根目录 然后删除 123final_flags.remove( &apos;-stdlib=libc++&apos; )except ValueError:pass 然后就可以补全了，美中不足的是每次打开cpp文件就会问是否加载配置文件 可以在.vimrc中配置 1234&quot;let g:ycm_global_ycm_extra_conf = &apos;~/.ycm_extra_conf.py&apos;&quot;Do not ask when starting vimlet g:ycm_confirm_extra_conf = 0let g:syntastic_always_populate_loc_list = 1 其中，g:ycm_global_ycm_extra_conf 定义了全局配置文件,当YCM在向上搜索的路径中找不到配置文件后，YCM将导入全局配置文件 g:ycm_confirm_extra_conf 决定了在导入配置时是否需要手动确认,设置为0后YCM就不会老是在启动vim的时候来烦你 快捷键 在此配置文件中，有许多插件键就是, Undotree : ,u,可以查看编辑历史，并可以跳转 NERDTree:,e/&lt;crtl-e&gt;可以查看目录 打开多文件后，文件之间的跳转是b(n),例如:b1 两个文件之间的切换是ctrl-6 bd是关闭该buffer，也就是关闭该文件 ctrlp:ctrl-p可以查看最近系统使用的文件，妈蛋，当时我正在听歌，然后显示的全都是我的歌 NERDCommenter:,cc，可以在v模式下快速注释和解除注释 Tagbar: ,tt可以打开类表，方便查看 /data是搜索，匹配之后n是跳跃 /s/data/replace/是替换 /nohl是取消搜索之后的高光 :terminal [zsh],可以打开shell，使用ctrl+ww可以在shell和vim间切换","categories":[],"tags":[{"name":"other","slug":"other","permalink":"http://originals-tz.github.io/tags/other/"}]},{"title":"关于操作系统的一些问题","slug":"OSQA","date":"2018-08-03T16:00:00.000Z","updated":"2018-08-04T15:51:16.594Z","comments":true,"path":"2018/08/04/OSQA/","link":"","permalink":"http://originals-tz.github.io/2018/08/04/OSQA/","excerpt":"","text":"Q1:软件如何访问硬件？ 访问硬件有两个方式 将外设的内存映射到一定范围的地址空间 此时，CPU通过地址总线访问到的内存区域会落到外设的内存中，例如CPU想显示在显示屏上显示东西，只需在显卡显存所映射到的地址范围内写入数据即可 通过IO接口与CPU通信 通过端口可以将数据传递给外设，在IO口上会有一些寄存器，电路根据写到寄存器的内容作出不同的反应，达到通信目的","categories":[],"tags":[{"name":"os","slug":"os","permalink":"http://originals-tz.github.io/tags/os/"}]},{"title":"The Semantics Of Data","slug":"C++DataSemantics","date":"2018-07-29T16:00:00.000Z","updated":"2018-08-21T02:26:34.786Z","comments":true,"path":"2018/07/30/C++DataSemantics/","link":"","permalink":"http://originals-tz.github.io/2018/07/30/C++DataSemantics/","excerpt":"Class Data 12345678910111213141516#include &lt;iostream&gt;class A &#123;&#125;;class B : public virtual A &#123;&#125;;class C : public virtual B&#123;&#125;;int main() &#123; std::cout &lt;&lt; \"Size Test\" &lt;&lt; std::endl; std::cout &lt;&lt; \"A:\" &lt;&lt; sizeof(A) &lt;&lt; std::endl; std::cout &lt;&lt; \"B:\" &lt;&lt; sizeof(B) &lt;&lt; std::endl; std::cout &lt;&lt; \"C:\" &lt;&lt; sizeof(B) &lt;&lt; std::endl; std::cout &lt;&lt; \"A Pointer:\" &lt;&lt; sizeof(A*) &lt;&lt; std::endl; return 0;&#125; 为什么？既然是空的类，那么更应该是0才对 然而输出的时候，A=1，B=8，C=8 不难理解，B和C存在vtpr，因此会占用4byte，而A并不是空，它存在隐藏的1byte","text":"Class Data 12345678910111213141516#include &lt;iostream&gt;class A &#123;&#125;;class B : public virtual A &#123;&#125;;class C : public virtual B&#123;&#125;;int main() &#123; std::cout &lt;&lt; \"Size Test\" &lt;&lt; std::endl; std::cout &lt;&lt; \"A:\" &lt;&lt; sizeof(A) &lt;&lt; std::endl; std::cout &lt;&lt; \"B:\" &lt;&lt; sizeof(B) &lt;&lt; std::endl; std::cout &lt;&lt; \"C:\" &lt;&lt; sizeof(B) &lt;&lt; std::endl; std::cout &lt;&lt; \"A Pointer:\" &lt;&lt; sizeof(A*) &lt;&lt; std::endl; return 0;&#125; 为什么？既然是空的类，那么更应该是0才对 然而输出的时候，A=1，B=8，C=8 不难理解，B和C存在vtpr，因此会占用4byte，而A并不是空，它存在隐藏的1byte C++中一个类的实例需要得到区分，那么就需要类里面可以装点东西，例如一个空类，然后声明3个实例，有点编译器就在类中插入一个char以区分不同的实例 由于这个原因，在B和C上也会存在一个char，这样一来，B=C=5byte 为了更有效的存储，B和C会受到 Memory Alignment (内存对齐)的限制，从而被拓展为8byte 但是如果是那种对Empty Virtual Base Class进行特别优化的编译器，那么额外的那个char将会被拿去，只用vptr标示，这样B和C都是8byte The Binding Of Data Member 在早期的C++编译器中，会出现class中的member function引用global object而不是data member的情况 12345678910111213141516extern float x;class Test &#123; public: float getX() &#123;return x;&#125; //将返回全局的x private: float x; //被无视掉&#125;//所以会出现防御型风格的classclass Test &#123; private: float x; public: float getX() &#123;return x;&#125;;&#125; 因为当时对data member的绑定是遇到就开始的 虽然现在已经改为整个class声明结束才开始，但是对于typedef仍需要防御型风格 1234567891011121314typedef int length;class Test &#123; Test(length i) &#123;&#125; //i被定义为int类型private: typedef float length;&#125;//防御型风格typedef int length;class Test &#123; typedef float length; Test (length i) &#123;&#125;&#125; Data Member Layout c++要求，同一个access section中(private, public, protected区段)中，member的排列要符合较晚出现的members要在class object中有较高的位置 也就是说，各个member不一定连续，原因是Memory Alignment时产生的byte 此外，编译器还会插入一些内部生成的data members,例如vptr，不过由于c++对内部的data members的位置持放任态度，因此甚至可能将其放置在程序员声明对data members之间 Data Member的存取 static Data Member 这是一个被编译器提出到class之外的member 正因如此，每一个static data member只有一个实例，存放在程序的data segment中 其存取并不需要通过object 1234567891011class Test &#123;public: static int i;&#125;int main() &#123; Test k; //k.i=34;等价于 Test::i=34; return 0;&#125; 即便static data member是通过层层继承过来的，仍可以使用以上方法进行存取 Nonstatic Data Member nonstatic data member存储在class object之中，只有借助显式或者隐式的class object才能存取它们 1234567891011121314151617181920class Test &#123;public: int i; Test();&#125;//所谓隐式Test::Test() &#123; i = 0;&#125;//等价于Test::Test(Test * const this) &#123; this-&gt;i = 0;&#125;//所谓显式int main() &#123; Test t; t.i = 0; return 0;&#125; 那为什么non-static data member的存取需要借助class object？ 因为欲对一个non-static data member进行存取，编译器需要吧class object的起始地址加上data member的偏移地址 12object.data = 0;&amp;object + (&amp;Test::data - 1); //取data的offset，且offset值总是会被+1 此时，由于offset的值在编译期便可得知，所以这时non-static data member的存取效率和struct是一样的 但是，如果加上虚拟继承呢？ 如果我们要存取的non-static data member是从virtual base class继承过来的，那么存取速度就会变慢 如下 12345Point3d origin;Point3dBaseClass *pt;pt-&gt;x = 0;origin.x = 0; 当x是从一个virtual base class中继承过来的，那么两种方法则会有很大差异 origin,我们知道它的起始地址就是Point3d的开头，那么，对x的offset也会在编译期确定下来 单pt则不同，我们不知道它指向的类型是Point3d还是Point3d 的 Base Class,这样一来，offset也无法确定，所以存取操作必须延迟到执行期 继承与Data Member derived class member和base class member的位置理论上可以由编译器自由安排，但是在大部分的编译器中，base class member会首先出现，前提是不存在virtual base class 本节将讨论 单一继承 单一继承+virtual function 多重继承 虚拟继承 单一继承 单一继承并不会增加空间和存取时间上的额外负担 但是，如果是糟糕的设计，那么将会因为内存对齐膨胀所需空间，例如，把一个class分解为多层 由于C++保证，出现在derived class中的base class具有完整的原样性，也就是说，在base class中为内存对齐安插的空间不变 假设base class的member所占空间为1，derived class的member所占空间为3，对齐为4 那么布局如下所示 12345678910111213141516171819对齐4base class: 1 + (3)----1----padding 3----derived class: 1 + (3) + 3 + 1----1----paddiing 3----3----padding 1 可以看出，derived class 所占空间是 1+(3)+3+(1)，而不是1+3 为什么会这样？因为如果不这样的话，就会在进行某些操作时破坏整个类的空间 12345678910class1 *p1, *p3;class2 *p2;p1 = new class1();p2 = new class2();p3 = p2;//发生截断，截断大小为class1的大小，但是由于derived class的member入侵到了base class的空间*p3 = *p1; //在进行memberwise的操作时，由于按照固定的内存大小拷贝//此时p1的空间没有被入侵，所以把p1空间复制到p3//会将p3所指空间的derived class的member覆盖掉//破坏了derived class的member 加上多态 支持多态性，势必会带来空间和存取时间上的负担 导入virtual table，存放每一个virtual function所带来的负担 导入vptr，提供vtbl地址所带来的负担 在constructor中初始化vptr所带来的负担 在deconstructor中，重设vptr 为什么要重设vptr？ 123456789101112class A &#123; A() &#123;get();&#125; ~A() &#123;get();&#125; virtual void get();&#125;;class B : public A &#123; B() &#123;get();&#125; void get();&#125;;A *p = new B(); p所指空间存在两种成分，A和B，p中只有一个vptr，A和B都通过vptr调用virtual函数 为了使得在A和B的构造函数能调用正确的get()，我们可以控制vptr的指向达到这个目的 vptr的初始化在于base class构造之后，在member初始化之前 123456789101112B() &#123; this-&gt;vptr = A::vtbl; A(); this-&gt;vptr = B::vtbl; //member initilization&#125;~B() &#123; //deconstructe this-&gt;vptr = A::vtbl; ~A();&#125; 对于vptr在布局中所处的位置，c++标准并没有规定，具体位置看不同厂商的编译器的实现 该讨论没有意义 多重继承 在多重继承下，一个 derived class 内含 n-1 个额外的 virtual tables ， n 表示其上一层 base classes 的个数；针对每一个 virtual tables, derived 对象中有对应的 vptr 123456789class A1;class A2 : public A1;class B;class C : public A2, public B;A1 *a1;A2 *a2;B *b;C *c; 将c转为b 123b = c ? //判断是否为空 (B*) ((char *)c + sizeof(A2)): 0; 不过对于A2和B的排列顺序并没有具体规定，上面的代码只是为了说明多重继承中的转化需要经过运算 虚拟继承 如果 1class B : public A1; B也继承与A1，那么在布局中就会含有两份A1，语言层面的解决方法就是使用虚拟继承 为了实现虚拟继承，会将A1分成两部分 不变区域 共享区域 共享区域会因为操作有所变化，而不变区域则不会 一般的布局是先安排好不变区域，然后再建立共享区域，那么如何存取共享部分？ cfront会在每一个derived class object中安插指针，指向virtual base class 1234class A1 &#123;int x;&#125;;class A2 : virtual public A1;class B : virtual public A1;class C : public A2, public B; 如果在B中有如下操作 123x++;----------转化为_VBCA1-&gt;x++; 如果要实现转化 12345A1 *a1;A2 *a2;a1 = a2;----------a1 = a2? a2-&gt;_VBCA1 : 0; 这个模型主要有两个问题 对于每一个virtual base class，derived class必须有一个指向virtual base class的指针，增加了空间成本 如果继承链加长，通过指针间接存取导致时间成本增加 对于第一个问题，有两种解决方法(注意⚠️，这不是标准) 可以设置virtual base class table 可以在virtual table中存放virtual base class的offset","categories":[],"tags":[{"name":"object model","slug":"object-model","permalink":"http://originals-tz.github.io/tags/object-model/"}]},{"title":"initialization member list","slug":"C++InitializationMemberList","date":"2018-07-24T16:00:00.000Z","updated":"2018-08-21T02:26:53.474Z","comments":true,"path":"2018/07/25/C++InitializationMemberList/","link":"","permalink":"http://originals-tz.github.io/2018/07/25/C++InitializationMemberList/","excerpt":"initialization member list 当以下情况，适于使用initialization member list对其进行初始化 初始化一个reference member 初始化一个const member 初始化constructor具有参数的base class 初始化constructor具有参数的member class","text":"initialization member list 当以下情况，适于使用initialization member list对其进行初始化 初始化一个reference member 初始化一个const member 初始化constructor具有参数的base class 初始化constructor具有参数的member class 如果没有使用initialization member list对变量进行初始化，而在函数内对其进行赋值操作，注意，是赋值，而不是初始化，那么效率就会变低 如果一个变量没有被显式初始化，那么就会隐式调用该变量的constructor，然后产生一个临时变量，再进行赋值操作，那么代价就是两次初始化，一次拷贝，一次析构 12345678String str;Constructor() &#123; str = String::String(); String temp = String(0); str.String::operator=(temp); temp.String::~String();&#125; 如果使用了initialization member list，代码会变成这样 12345Constructor():str(0) &#123;&#125;||Constructor() &#123; str.String::String(0);&#125; 值得注意的是，初始化的顺序由定义顺序决定 123456String str;int number;Constructor() : number(0), str(\"nice\") &#123;&#125;||Constructor() : str(\"nice\"), number(0) &#123;&#125; 也就是说人为安排初始化顺序是无用功，因为不会受人为安排的顺序影响，只与变量定义有关 123int number;int i;Constructor() : i(0), number(i) &#123;&#125; 上面这段代码则是错误的，因为number先定义，那么number(i)则是未知取值 同样，关于初始化的问题，还有另一种形式 123X::X(int val) : i(xfoo(val)) &#123; &#125; 这种形式的初始化，如果xfoo()存在于class之内，那么就十分危险，如果xfoo()的正确执行依赖于其他class member的初始化，那么就会导致bug 如果使用derived class的member来初始化base class，也有可能会出现bug 123456789101112131415class Foo : public x &#123; private: int _fval; public: int fval() &#123;return _fval;&#125; Foo(int val) : fval(val), X(fval()) &#123; &#125;&#125;//其中Foo可能会被扩充为Foo(int val) &#123; X::X(this, this-&gt;fval()); _fval = val;&#125; 其中大概的原因是 base class会先被初始化，然后才到derived class的初始化","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://originals-tz.github.io/tags/c/"}]},{"title":"Memory Alignment","slug":"MemoryAlignment","date":"2018-07-20T16:00:00.000Z","updated":"2018-08-21T02:28:37.265Z","comments":true,"path":"2018/07/21/MemoryAlignment/","link":"","permalink":"http://originals-tz.github.io/2018/07/21/MemoryAlignment/","excerpt":"关于内存对齐的一点探讨","text":"关于内存对齐的一点探讨 为什么需要内存对齐 内存对齐是一种提高内存访问速度的策略，cpu在访问未对齐的内存需要经过两次内存访问，而经过内存对齐一次就可以了 计算机在读取内存的时候，是一块一块的读取的 1234我们认为是一个一个的读取的|1|2|3|4|5|6|7|8|但cpu是一块一块地读取的，也就是先读1234，再读5678|1|2|3|4|------|5|6|7|8| 那为什么需要内存对齐？因为如果你不理解内存对齐，有可能会导致 程序运行速度变慢 应用程序产生死锁 操作系统崩溃 你的程序会毫无征兆的出错,产生错误的结果 首先这里只关注第一个(其余3个都与平台和硬件相关)，程序运行速度变慢？why？ 因为如果存在以下的结构体 12345struct Test &#123; char c1; //1 int i; //4 char c1; //1&#125; Test的内存结构是这样的 12|c1|i|i|i||i|c2| | | 那么为了读取i，cpu要读取两次并将其拼接，才能够得到i的值，为了更高的效率 可以这样摆放 123|c1| | | ||i|i|i|i||c2| | | | 这样的话就能一次性将i读取出来 123456789101112131415161718#program pack(4)struct Test &#123; char c1; int i; char c2;&#125;;int main() &#123; Test v; printf(\"%p\\n\", &amp;v.c1); printf(\"%p\\n\", &amp;v.i); printf(\"%p\\n\", &amp;v.c2); return 0;&#125;//可以看出编译器已经进行了内存对齐0x7ffeee79c9f00x7ffeee79c9f40x7ffeee79c9f8 成员对齐与整体对齐 所谓成员对齐，就如上面说的例子 123456|c1|i|i|i||i|c2| | |变成|c1| | | ||i|i|i|i||c2| | | | 为了更高的读取效率，可以往后c1添加3个字节，那么为什么一定要添加3个字节？ 这就和对齐系数有关了，#pragma pack(n)可以指定对齐系数 不同平台上编译器的 pragma pack 默认值不同。而我们可以通过预编译命令#pragma pack(n), n= 1,2,4,8,16来改变对齐系数 整体对齐与数据对齐相似但不是完全相同 如果数据对齐完成时struct的大小不是struct内成员自身长度最大值（sizeof） 与 #pragma pack(n)中的n的最小值的整数倍 注意这里是成员中长度最大的那个与n比较，而不是特定的一个成员。就要在struct的最后添加空字节直到对齐 例如一个struct在数据对齐之后，整个的大小是6byte，但是对齐系数是4，那么就要往后添加2byte","categories":[],"tags":[{"name":"other","slug":"other","permalink":"http://originals-tz.github.io/tags/other/"}]},{"title":"返回类型与函数重载","slug":"TypeOfReturn&Override","date":"2018-05-14T16:00:00.000Z","updated":"2018-08-01T15:58:33.265Z","comments":true,"path":"2018/05/15/TypeOfReturn&Override/","link":"","permalink":"http://originals-tz.github.io/2018/05/15/TypeOfReturn&Override/","excerpt":"我们知道，函数重载是指在同一作用域内，可以有一组具有相同函数名，不同参数列表的函数，这组函数被称为重载函数 那么为什么我们不能通过返回类型的不同来进行函数重载？","text":"我们知道，函数重载是指在同一作用域内，可以有一组具有相同函数名，不同参数列表的函数，这组函数被称为重载函数 那么为什么我们不能通过返回类型的不同来进行函数重载？ 因为在编译中，每一个函数都会按照一定的规则进行映射 test.cpp 12345678910111213141516171819202122232425262728namespace t&#123; float test(float i) &#123; i = 1.2; return i; &#125; float test() &#123; return 1.2; &#125;&#125;float test(float i) &#123; i = 3.4; return i;&#125;int test(int i)&#123; i = 1; return i;&#125;float output(float i, int d) &#123; d = 3; i = 1.4; return i;&#125; 然后我们查看它的汇编代码 12g++ -g -c test.cppobjdump -S test.o &gt; test_obj.s //可以和源代码一起看，酸爽！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768691.o: file format Mach-O 64-bit x86-64Disassembly of section __TEXT,__text:__ZN1t4testEf:; &#123; 0: 55 pushq %rbp 1: 48 89 e5 movq %rsp, %rbp 4: f3 0f 10 0d 8c 00 00 00 movss 140(%rip), %xmm1 c: f3 0f 11 45 fc movss %xmm0, -4(%rbp); i = 1.2; 11: f3 0f 11 4d fc movss %xmm1, -4(%rbp); return i; 16: f3 0f 10 45 fc movss -4(%rbp), %xmm0 1b: 5d popq %rbp 1c: c3 retq 1d: 0f 1f 00 nopl (%rax)__ZN1t4testEv:; float test() &#123; 20: 55 pushq %rbp 21: 48 89 e5 movq %rsp, %rbp 24: f3 0f 10 05 70 00 00 00 movss 112(%rip), %xmm0; return 1.2; 2c: 5d popq %rbp 2d: c3 retq 2e: 66 90 nop__Z4testf:; float test(float i) &#123; 30: 55 pushq %rbp 31: 48 89 e5 movq %rsp, %rbp 34: f3 0f 10 0d 64 00 00 00 movss 100(%rip), %xmm1 3c: f3 0f 11 45 fc movss %xmm0, -4(%rbp); i = 3.4; 41: f3 0f 11 4d fc movss %xmm1, -4(%rbp); return i; 46: f3 0f 10 45 fc movss -4(%rbp), %xmm0 4b: 5d popq %rbp 4c: c3 retq 4d: 0f 1f 00 nopl (%rax)__Z4testi:; &#123; 50: 55 pushq %rbp 51: 48 89 e5 movq %rsp, %rbp 54: 89 7d fc movl %edi, -4(%rbp); i = 1; 57: c7 45 fc 01 00 00 00 movl $1, -4(%rbp); return i; 5e: 8b 45 fc movl -4(%rbp), %eax 61: 5d popq %rbp 62: c3 retq 63: 66 66 66 66 2e 0f 1f 84 00 00 00 00 00 nopw %cs:(%rax,%rax)__Z6outputfi:; float output(float i, int d) &#123; 70: 55 pushq %rbp 71: 48 89 e5 movq %rsp, %rbp 74: f3 0f 10 0d 28 00 00 00 movss 40(%rip), %xmm1 7c: f3 0f 11 45 fc movss %xmm0, -4(%rbp) 81: 89 7d f8 movl %edi, -8(%rbp); d = 3; 84: c7 45 f8 03 00 00 00 movl $3, -8(%rbp); i = 1.4; 8b: f3 0f 11 4d fc movss %xmm1, -4(%rbp); return i; 90: f3 0f 10 45 fc movss -4(%rbp), %xmm0 95: 5d popq %rbp 96: c3 retq 从上面我们不难看出 __ZN1t4testEf int t::test (int) __ZN1t4testEv: float t::tset(void) __Z4testf : float test(float i) __Z4testi : int test(int) __Z6outputfi : float output(float, int) 根据上面的对比，我们大致可以推断出命名规则为作用域+函数名+参数类型 例如 : ZN1t4 和Z4 代表两个不同的作用域 而output的Z6 output fi中的fi则表示的是参数类型，f表示float，i表示int 综上所述，映射后的函数名完全没有返回值什么事，当你调用一个函数，编译器首先要看看函数名列表，然后根据你的参数进行一个匹配 重载中最重要的就是对应函数的查找，为了正确查找函数，我们不能定义两个参数类型和函数名一样的函数，这是编译器生成的代码规则所决定的 如果你两个函数的作用域，函数名，参数类型都一样，那么也查找不到对应的函数了，如下(错误的代码) 123456//汇编之后的函数名(用下划线分割规则）int test() &#123;return 1;&#125; //__Zn_test_vfloat test() &#123;return 1.2;&#125;//__Zn_test_v//两个都是一样的，二义性 这就是为什么不能仅仅通过返回值类型不同来进行重载","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://originals-tz.github.io/tags/c/"}]},{"title":"Template Base--Function Template","slug":"C++FunctionTemplate","date":"2018-05-14T16:00:00.000Z","updated":"2018-08-21T02:26:45.788Z","comments":true,"path":"2018/05/15/C++FunctionTemplate/","link":"","permalink":"http://originals-tz.github.io/2018/05/15/C++FunctionTemplate/","excerpt":"模板(template)是为了支持泛型编程(Generic programming)而存在的，所谓泛型，也就是不依赖于具体类型,wiki对其定义如下 Generic programming is a style of computer programming in which algorithms are written in terms of types to-be-specified-later that are then instantiated when needed for specific types provided as parameters. Generic programming --wikipedia","text":"模板(template)是为了支持泛型编程(Generic programming)而存在的，所谓泛型，也就是不依赖于具体类型,wiki对其定义如下 Generic programming is a style of computer programming in which algorithms are written in terms of types to-be-specified-later that are then instantiated when needed for specific types provided as parameters. Generic programming --wikipedia 为了更直观的了解，我们先看看相对于一般的编程方式，范型编程是怎么样的 123456789101112131415161718192021#include &lt;iostream&gt;int max_normal(int a, int b) &#123; return a &gt; b? a : b;&#125;template &lt;typename T&gt;T max_generic(T a, T b) &#123; return a &gt; b? a : b;&#125;#define Log(x) std::cout&lt;&lt;x&lt;&lt;std::endl;int main() &#123; //int Log(max_normal(1, 2)); //2 Log(max_generic(1, 2));//2 //float Log(max_normal(1.1, 1.2));//1 Log(max_generic(1.1, 1.2));//1.2 return 0;&#125; 对于多种数据类型，普通函数要声明不同的版本 12float max(float, float);int max(int, int); 这将导致大量的重复工作，为此，我们需要解放自己，这时候泛型编程登场了 1234template&lt;typename T&gt;T max(T x, T y) &#123; return x &gt; y? x : y;&#125; 就一个函数的事，多么简洁而优雅！模板就如蓝图一样，对于实例化模板参数的每一种类型，都从模板中产生一个不同的实体，下面就是测试 12345678910111213#include &lt;iostream&gt;template &lt;typename T&gt;T max_generic(T a, T b) &#123; return a &gt; b? a : b;&#125;#define Log(x) std::cout&lt;&lt;x&lt;&lt;std::endl;int main() &#123; //使用 int 进行实例化 Log(max_generic(1, 2)); //使用 double 进行实例化 Log(max_generic(1.1, 1.2)); return 0;&#125; 然后我们就会得到两个实例… 12345678//自动生成的int max_generic(int a, int b) &#123; return a &gt; b? a : b;&#125;double max_generic(double a, double b) &#123; return a &gt; b? a : b;&#125; 如果还不相信的话，我们就来看看对应的汇编代码 g++ -g -c source.cpp &amp; objdump -S source.o &gt; source_obj.s 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162631.o: file format Mach-O 64-bit x86-64Disassembly of section __TEXT,__text:_main:; int main() &#123; 0: 55 pushq %rbp 1: 48 89 e5 movq %rsp, %rbp 4: 48 83 ec 10 subq $16, %rsp 8: bf 01 00 00 00 movl $1, %edi d: be 02 00 00 00 movl $2, %esi; max(1, 2); 12: e8 00 00 00 00 callq 0 &lt;_main+0x17&gt; 17: f2 0f 10 05 91 00 00 00 movsd 145(%rip), %xmm0 1f: f2 0f 10 0d 91 00 00 00 movsd 145(%rip), %xmm1; max(1.1, 1.2); 27: 89 45 fc movl %eax, -4(%rbp) 2a: e8 00 00 00 00 callq 0 &lt;_main+0x2F&gt; 2f: 31 c0 xorl %eax, %eax; &#125; 31: f2 0f 11 45 f0 movsd %xmm0, -16(%rbp) 36: 48 83 c4 10 addq $16, %rsp 3a: 5d popq %rbp 3b: c3 retq 3c: 0f 1f 40 00 nopl (%rax)__Z3maxIiET_S0_S0_:; T max(T x, T y) &#123; 40: 55 pushq %rbp 41: 48 89 e5 movq %rsp, %rbp 44: 89 7d fc movl %edi, -4(%rbp) 47: 89 75 f8 movl %esi, -8(%rbp); return x &gt; y? x : y; 4a: 8b 75 fc movl -4(%rbp), %esi 4d: 3b 75 f8 cmpl -8(%rbp), %esi 50: 0f 8e 0b 00 00 00 jle 11 &lt;__Z3maxIiET_S0_S0_+0x21&gt; 56: 8b 45 fc movl -4(%rbp), %eax 59: 89 45 f4 movl %eax, -12(%rbp) 5c: e9 06 00 00 00 jmp 6 &lt;__Z3maxIiET_S0_S0_+0x27&gt; 61: 8b 45 f8 movl -8(%rbp), %eax 64: 89 45 f4 movl %eax, -12(%rbp) 67: 8b 45 f4 movl -12(%rbp), %eax 6a: 5d popq %rbp 6b: c3 retq 6c: 0f 1f 40 00 nopl (%rax)__Z3maxIdET_S0_S0_:; T max(T x, T y) &#123; 70: 55 pushq %rbp 71: 48 89 e5 movq %rsp, %rbp 74: f2 0f 11 45 f8 movsd %xmm0, -8(%rbp) 79: f2 0f 11 4d f0 movsd %xmm1, -16(%rbp); return x &gt; y? x : y; 7e: f2 0f 10 45 f8 movsd -8(%rbp), %xmm0 83: 66 0f 2e 45 f0 ucomisd -16(%rbp), %xmm0 88: 0f 86 0f 00 00 00 jbe 15 &lt;__Z3maxIdET_S0_S0_+0x2D&gt; 8e: f2 0f 10 45 f8 movsd -8(%rbp), %xmm0 93: f2 0f 11 45 e8 movsd %xmm0, -24(%rbp) 98: e9 0a 00 00 00 jmp 10 &lt;__Z3maxIdET_S0_S0_+0x37&gt; 9d: f2 0f 10 45 f0 movsd -16(%rbp), %xmm0 a2: f2 0f 11 45 e8 movsd %xmm0, -24(%rbp) a7: f2 0f 10 45 e8 movsd -24(%rbp), %xmm0 ac: 5d popq %rbp ad: c3 retq 我们可以看到max一共有两个函数名 __Z3maxIiET_S0_S0 = int max(int, int) __Z3maxIdET_S0_S0,=double max(double, double) 好嘞，对底层的验证点到为止，那么接下来我们将迎来重头戏 模板参数的推导(deduction) 函数模版有两种类型的参数 template ： T是模板参数 max(T x, T y) : x, y是调用参数 模板参数要求必须要全部推导出来，函数模板可以通过传入实参来推导模板参数，如果推导失败，那么就会发生错误 1max(1, 1.5); //max(int, double), 推导失败 如果没有全部推导，也会发生错误 12345template&lt;typename T1, typename T2&gt;void foo(T1 x);foo(1); //只有T1被推导出来，T2没有被推导，错误！foo&lt;int, int&gt;(1); //显示指定模板参数，成功 一般而言，不会去转化实参类型以匹配已有的实例，不过有些情况除外 const转换： 如果模板形参为const引用，则其可以接受const或非const引用 如果模板形参为const指针，则其可以接受const或非const指针 如果模板形参不是引用或指针（值传递），则形参和实参都忽略const 数组或函数到指针的转换 如果模板形参不是引用或指针（值传递），则数组会转化为指针，数组实参将当作指向其第一个元素的指针； 如果模板形参不是引用或指针（值传递），则函数会转化为指针，函数实参将当作指向函数类型的指针； 1234567891011121314151617181920template&lt;typename T&gt;void fobj(T x) &#123; x = 3;&#125;template&lt;typename T&gt;void fref(const T&amp; v) &#123;&#125;int main() &#123; int a = 1; const int b = 2; fobj(b); fref(a); fref(b); return 0;&#125; 但是有时候，模板推断可能会出乎我们的预料 123456789template&lt;typename T&gt;void fref(T&amp; x) &#123;&#125;int main() &#123; const int b = 4; fref(b);//ok! return 0;&#125; 道理上来说，这样的推断是错误的，但是我们可以看到在函数中并没有对x进行任何修改，因此可以匹配 但是如果在函数中加入x=3那么，编译就会报错，这就在情理之中了 另外从C++11开始，已经可以用模板来推导模板参数了 例如 1234567891011121314151617#include &lt;iostream&gt;template&lt;typename T, int F&gt;void fun(T i) &#123; i = i + F;&#125;template&lt;typename T&gt;void test(T i) &#123; std::cout &lt;&lt; std::is_same&lt;T, void(*)(int)&gt;::value &lt;&lt; std::endl; // true, T被推导为函数指针void(*)(int) i(3);&#125;int main() &#123; test(fun&lt;int, 2&gt;); return 0;&#125; 函数模板的重载与匹配 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;typeinfo&gt;#define Log(x) std::cout&lt;&lt;x&lt;&lt;std::endlconst int &amp; max(const int &amp;a, const int &amp;b) &#123; Log(\"normal\"); return a &gt; b? a : b;&#125;template&lt;typename T&gt;T const &amp; max(const T &amp;a, const T &amp;b) &#123; Log(\"template\"); return a &gt; b? a : b;&#125;template&lt;typename T&gt;T const &amp; max(const T &amp;a, const T &amp;b, const T &amp;c) &#123; Log(\"template\"); return max(max(a, b), c);&#125;int main() &#123; Log(max(1, 2)); Log(max(1.2, 2.4)); Log(max(1, 2, 3)); return 0;&#125; 注意，实例化模版也是有代价的，如果能通同时匹配到一般函数和模板函数，就使用一般函数 模板不允许隐式转换，因此如果两个类型不同，就会考虑一般函数(如上),max(int, float)就会匹配一般函数","categories":[],"tags":[{"name":"template","slug":"template","permalink":"http://originals-tz.github.io/tags/template/"}]},{"title":"Linux之exec族函数","slug":"LinuxExec","date":"2018-04-20T16:00:00.000Z","updated":"2018-08-21T02:28:14.565Z","comments":true,"path":"2018/04/21/LinuxExec/","link":"","permalink":"http://originals-tz.github.io/2018/04/21/LinuxExec/","excerpt":"一直以来都不怎么清楚exec函数族，现在就来总结一下","text":"一直以来都不怎么清楚exec函数族，现在就来总结一下 12345678910#include &lt;unistd.h&gt;//execl系列int execl(const char *path, const char *arg, ...)int execlp(const char *file, const char *arg, ...)int execle(const char *path, const char *arg, ..., char *const envp[])//execv系列int execv(const char *path, char *const argv[])int execve(const char *path, char *const argv[], char *const envp[])int execvp(const char *file, char *const argv[]) 描述 exec()系列函数使用新的进程映像替换当前进程映像,工作方式没有什么差别, 只是参数传递的方式不同罢了. 说明 这6个函数可分为两大类: execl()系列 和 execv()系列. ‘l’ 是指把所有传递给程序的参数依次列(list)出来. ‘v’ 是指把所有参数放到容器(数组, vector)中再一次性传入. 不论是list出来还是vector them all, 参数的最后一个都必须为空指针((char*)0都行). 没有以p/e结尾的execl()和execv()使用绝对路径(path)执行第1个参数给定的文件. ‘p’ 是指第1个参数位于默认的环境变量PATH中, 仅用文件(file)指出文件名即可. ‘e’ 是指第1个参数位于给定的envp环境变量中., 用绝对路径(path)给出待执行文件. 注意arg0: 应该始终为待执行文件的文件名 示例 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main(void)&#123; char* const argv[] = &#123;\"ps\", \"ax\", 0&#125;; char* const envp[] = &#123;\"PATH=/bin:/usr/bin\", 0&#125;; int i = 0; scanf(\"%d\",&amp;i); switch(i) &#123; case 1: execl(\"/bin/ps\", \"ps\", \"ax\", NULL); case 2: execlp(\"ps\", \"ps\", \"ax\", NULL); case 3: execle(\"/bin/ps\", \"ps\", \"ax\", NULL, envp); case 4: execv(\"/bin/ps\", argv); case 5: execvp(\"ps\", argv); case 6: execve(\"/bin/ps\", argv, envp); &#125; return 0;&#125;","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://originals-tz.github.io/tags/Linux/"}]},{"title":"STL之iterator与traits技术","slug":"STL_Iterator","date":"2018-04-18T16:00:00.000Z","updated":"2018-08-01T15:58:27.841Z","comments":true,"path":"2018/04/19/STL_Iterator/","link":"","permalink":"http://originals-tz.github.io/2018/04/19/STL_Iterator/","excerpt":"iterator模式定义如下：提供一种方法，使之能够依序寻访某个聚合物所含的各个元素，而又无需暴露该聚合物的内部表达形式 其中，c++里面各个容器的iterator扮演着将数据容器与算法结合起来的重要角色 将范型算法(find, count, find_if)用于某个容器中,最重要的是要给算法提供一个访问容器元素的工具，iterator就扮演着这个重要的角色","text":"iterator模式定义如下：提供一种方法，使之能够依序寻访某个聚合物所含的各个元素，而又无需暴露该聚合物的内部表达形式 其中，c++里面各个容器的iterator扮演着将数据容器与算法结合起来的重要角色 将范型算法(find, count, find_if)用于某个容器中,最重要的是要给算法提供一个访问容器元素的工具，iterator就扮演着这个重要的角色 我们在算法中可能会定义简单的中间变量或者设定算法的返回变量类型，这时候需要知道迭代器所指元素的类型是什么，但是由于没有typeof这类判断类型的函数,我们无法直接获取，那该如何是好？ 不要急，那首先先介绍一下iterator_tarit iterator_trait 123456789template&lt;class _Tp&gt;struct iterator_traits&lt;_Tp*&gt;&#123; typedef ptrdiff_t difference_type; typedef typename _Tp::value_type value_type; typedef typename _Tp::pointer pointer; typedef typename _Tp::reference reference; typedef typename _Tp::iterator_category iterator_category;&#125;; 看到这个奇奇怪怪的东西，是不是感觉没什么用，嗯，没关系，先记着 下面，将接着之前的话题，来看看如何提取出iterator所指向的元素类型 value_type 例如 使用typedef 我们可以在迭代器中添加元素的类型 1234567891011121314template &lt;class T&gt;struct MyIter &#123; typedef T value_type; T * ptr; MyIter(T * p = 0) : ptr (p) &#123;&#125;; T&amp; operator* () const &#123; return *ptr;&#125;&#125;;template &lt;class I&gt;typename I::value_type //取出迭代器类中的类型//用以设定返回变量类型，但是如果I是指针就会错误get (I ite) &#123; return *ite;&#125; 但是，这个版本并不支持原生指针，然而就迭代器的行为而言，就是面向容器的指针，而正常的STL算法也是支持原生指针的，就如同下面的find一样 指针和迭代器的作用无非就是为stl算法提供了一个运算范围以及对容器（无论是vector，list，亦或是array）的访问 1234567int main() &#123; int a[5] = &#123;1,2,2,2,2&#125;; int *begin = a; int *end = a+5; int count = std::count(begin, end, 2); //ok! return 0;&#125; 所以对于第一个版本，我们还要对指针类型进行模版偏特化 提取以及偏特化 前面也提到了，如果直接使用typename I::value_type，算法就无法接收原生指针，因为原生指针根本就没有value_type这个内嵌类型 因此，我们还需要加入一个中间层对其进行判断，看它是不是原生指针，注意，这就是traits技法的妙处所在 如果我们只使用上面的做法，也就是内嵌value_type，那么对于没有value_type的指针，我们只能对其进行偏特化，这种偏特化是针对可调用函数get的偏特化，假如get有100行代码，那么就会造成极大的视觉污染 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;template &lt;class T&gt;struct MyIter &#123; typedef T value_type; T * ptr; MyIter(T * p = 0) : ptr (p) &#123;&#125;; T&amp; operator* () const &#123; return *ptr;&#125;&#125;;template &lt;class I&gt;typename I::value_type //取出迭代器类中的类型get (I ite) &#123; std::cout &lt;&lt; \"class version\" &lt;&lt; std::endl; return *ite;&#125;template &lt;class I&gt;I get(I* ite) &#123; std::cout &lt;&lt; \"pointer version\" &lt;&lt; std::endl; return *ite;&#125;template &lt;class I&gt;I get(const I* ite) &#123; std::cout &lt;&lt; \"const pointer version\" &lt;&lt; std::endl; return *ite;&#125;int main() &#123; int i = 3; const int k = 3; MyIter&lt;int&gt; v(&amp;i); std::cout &lt;&lt; get(v) &lt;&lt; std::endl; std::cout &lt;&lt; get(&amp;i) &lt;&lt; std::endl; std::cout &lt;&lt; get(&amp;k) &lt;&lt; std::endl; return 0;&#125; 就如同上面这个形式，设想往get中填充100行代码，简直不忍直视，你再看看下面这个，简直优雅！ 利用一个中间层iterator_traits固定了get的形式，使得重复的代码大量减少，唯一要做的就是稍稍特化一下iterator_tartis使其支持pointer和const pointer😃 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;template &lt;class T&gt;struct iterator_traits &#123; typedef typename T::value_type value_type;&#125;;template &lt;class T&gt;struct iterator_traits&lt;T*&gt; &#123; typedef T value_type;&#125;;template &lt;class T&gt;struct iterator_traits&lt;const T*&gt; &#123; typedef T value_type;&#125;;template &lt;class T&gt;struct MyIter &#123; typedef T value_type; T * ptr; MyIter(T * p = 0) : ptr (p) &#123;&#125;; T&amp; operator* () const &#123; return *ptr;&#125;&#125;;template &lt;class I&gt;typename iterator_traits&lt;I&gt;::value_typeget (I ite) &#123; std::cout &lt;&lt; \"normal version\" &lt;&lt; std::endl; return *ite;&#125;int main() &#123; int i = 3; const int k = 3; MyIter&lt;int&gt; v(&amp;i); std::cout &lt;&lt; get(v) &lt;&lt; std::endl; std::cout &lt;&lt; get(&amp;i) &lt;&lt; std::endl; std::cout &lt;&lt; get(&amp;k) &lt;&lt; std::endl; return 0;&#125; 通过定义内嵌类型，我们获得了知晓iterator所指元素类型的方法，通过traits技法，我们将函数模板对于原生指针和自定义iterator的定义都统一起来 这就是traits技法的妙处所在 difference type difference type用于表示两个迭代器之间的距离的一个类型,也可以用来表示一个容器的最大的容量，因为对于连续空间的容器，头尾之间的距离就是最大容量 例如count()就必须返回的类型就是迭代器的difference type 对于STL容器类型，以及原生指针，traits有如下两个不同版本 123456789101112131415161718template&lt;class I&gt;struct iterator_traits &#123;... typedef typename I::difference_type difference_type;&#125;//原生指针template&lt;class I&gt;struct iterator_traits&lt;T*&gt; &#123;... typedef ptrdiff_t difference_type;&#125;template&lt;class I&gt;struct iterator_traits&lt;const T*&gt; &#123;... typedef ptrdiff_t difference_type;&#125; reference type 标示了引用类型 pointer 标示了指针类型 测试 以上说明了迭代器内部的几种重要类型 下面对其进行一个测试，以此产生一个更直观的印象 1234567891011121314#include &lt;iostream&gt;#include &lt;vector&gt;#define Test(x,z,y) std::cout&lt;&lt;std::is_same&lt;std::iterator_traits&lt;x&gt;::z,y&gt;::value&lt;&lt;std::endlint main() &#123;#define IVec std::vector&lt;int&gt;::iterator Test(IVec,value_type,int); //true Test(IVec,difference_type,ptrdiff_t); //true Test(IVec,reference,int&amp;); //true Test(IVec,pointer,int*); //true return 0;&#125; 从上面可以看出，一个vector&lt;int&gt;::iterator value_type=int difference_type=ptrdiff_t reference=int&amp; pointer=int* 总结 要牢记iterator是为了访问容器内的元素而存在的，而它内置的类型就是范型算法与容器进行沟通的重要工具 而我们使用traits技法主要是为了解决原生指针和自定义iterator之间的不同所造成的代码冗余 type traits type traits的出现和STL对于性能的要求有着千丝万缕的联系 试想，对于vector这种大块分配内存，然后大块析构的容器，如果容器里面是POD的话，那么只要等它的生命周期结束就行了，如果是非POD的话，那么就要判断是否拥有no-traits的析构函数 如果是这样的话，又回到了之前value_type的窘境，因此，我们只需要使用type_traits，对POD进行偏特化，通过两个神奇的类型进行判断 12struct _true_type&#123;&#125;;//无意义的析构函数 struct _false_type&#123;&#125;;//有意义的析构函数 这样子就可以让负责析构的模块进行判断了 具体的type_traits如下所示 1234567891011121314template&lt;typename T&gt; struct type_traits &#123; typedef _false_type has_trivial_default_constructor;//默认构造函数是否有意义？ typedef _false_type has_trivial_copy_constructor;//拷贝构造函数是否有意义? typedef _false_type has_trivial_assgignment_constructor;//拷贝赋值操作是否有意义? typedef _false_type has_trivial_destructor;//析构函数是否有意义? /*POD意指Plain Old Data,也就是标量型别或传统的C struct(传统的C struct只能 包含数据成员，不能包含函数成员。也就是所谓的聚合类。POD型别必然包含无意义 的ctor/dtor/copy/assignment函数。 */ typedef _false_type is_POD_type;//是否为Plain Old Data? &#125;; 总结 通过对type_traits进行特化，标注自己类中的构造，拷贝等行为是否是有意义的，可以大大提高适配算法的效率，这也是type traits存在的意义","categories":[],"tags":[{"name":"STL","slug":"STL","permalink":"http://originals-tz.github.io/tags/STL/"}]},{"title":"C++ Stream IO","slug":"C++StreamIO","date":"2018-04-16T16:00:00.000Z","updated":"2018-08-01T15:57:33.247Z","comments":true,"path":"2018/04/17/C++StreamIO/","link":"","permalink":"http://originals-tz.github.io/2018/04/17/C++StreamIO/","excerpt":"c++ IO由stream 完成，所谓的输入输出，就是字符流入stream和字符流出stream的过程,其中最重要的莫过于 istream定义input stream，用来读取数据 ostream定义output stream，用来写数据","text":"c++ IO由stream 完成，所谓的输入输出，就是字符流入stream和字符流出stream的过程,其中最重要的莫过于 istream定义input stream，用来读取数据 ostream定义output stream，用来写数据 IOStram定义了数个istream和ostream全局对象，对应标准IO的3个通道 在linux中的文件描述符为 0 ： stdin : cin 1 ： stdout : cout 2 ： stderr : cerr, clog Manipulator 操作符 class 意义 endl ostream 输出\\n并刷新 ends ostream 输出\\0并刷新 flush ostream 刷新 ws istream 跳过空白字符 other manipulator &lt;&lt; basic_ostream将&lt;&lt;定义为output操作符，对所有内建类型进行了重载，除了null和nullptr_t，但是包括char* 和 void* 得益于其拓展性，因此我们可以对自定义类型进行重载，这样就可以保证对任意类型都会推断出正确的打印函数 如 1234567struct test &#123; std::string str;&#125;;std::ostream &amp; operator&lt;&lt;(std::ostream &amp;out, test t) &#123; return out &lt;&lt; t.str;&#125; 要注意的是，重载的&lt;&lt;运算符必须是全局的，因此对于要输出private成员的class我们需要设置friend属性 &gt;&gt; &amp; &lt;&lt; &gt;&gt;被定义成input运算符 &lt;&lt;被定义成output运算符 可以从方向判断数据的流向 例如 12std::cout &lt;&lt; \"hello\"; //流入cout缓冲区std::cin &gt;&gt; i; //从cin流入i Stream State(flag) 常量 意义 goodbit 一切都好，没有任何其他bit被设置 eofbit 遇到end-of-file failbit 错误，某个IO未完成，例如输入int但却混杂了一个char（格式错误） badbit 毁灭性错误，例如文件指针设置错误导致的读写失败 字母在输入的时候并不会隐式转换为整形，以下是测试代码 12345678910#include &lt;iostream&gt;using namespace std;int main() &#123; int k; cin &gt;&gt; k; if (cin.badbit) &#123; cout &lt;&lt; \"the bad bit has been set\" &lt;&lt; endl; &#125; return 0;&#125; Handle Stream State 函数 意义 good() 返回goodbit eof() 返回eofbit fail() 返回failbit或者badbit bad() 返回badbit rdstate() 返回当前设置的所有flag clear() 清除所有flag clear(state) 清除所有flag并设置state setstate(state) 设置state flag Stream Boolean 成员函数 意义 operator bool Stream是否已经出错,!fail() operator ! stream是否已经出错,fail() Input function int istream::get() 读取一个字符 返回读取的字符或者EOF istream&amp; istream::get (char&amp; c) 把下一个字符赋值给c 通过返回stream可以判断是否读取成功 istream&amp; get(char *, streamsize) 终止条件是下一个字符是换行符，但不会将其读取，还会保留在缓冲区中 12345basic_istream &amp;get(char_type* __s, streamsize __n) &#123; return get(__s, __n, this-&gt;wident('\\n'));&#125; 以下代码,除了第一个std::cin.get()起作用，其他的都是直接读取缓冲区的\\n 12345678910#include &lt;iostream&gt;int main() &#123; char a[10]; std::cin.get(a, 10); std::cin.get(a, 10); std::cin.get(a, 10); std::cout &lt;&lt; a &lt;&lt; std::endl; return 0;&#125; 原因在于遇到\\n就结束，但是并不从缓冲区中把\\n取走 因此接下来的每次读取都会遇到残留在输入缓冲区里面的\\n 所以要想办法 把\\n取走，例如，加入std::get()取走\\n 直接清空缓冲区,std::cin.ignore() istream&amp; istream::get(char* str, streamsize count, char delim) 读取的字符序列以null结尾 不会读取终止符delim istream&amp; istream::getline(char* str, streamsize count) istream&amp; istream::getline(char* str, streamsize count, char delim) 会读取结束字符 delim(\\n) 但是str不会存储结束字符 其余与get一样","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://originals-tz.github.io/tags/c/"}]},{"title":"Socket之僵尸进程","slug":"SocketZombie","date":"2018-04-12T16:00:00.000Z","updated":"2018-08-21T02:29:10.498Z","comments":true,"path":"2018/04/13/SocketZombie/","link":"","permalink":"http://originals-tz.github.io/2018/04/13/SocketZombie/","excerpt":"僵尸进程是指完成执行，但是仍有一个对应的PCB残留在进程表中，处于终止态的进程 一般而言，僵尸进程会被父进程wait进行回收，如果没有得到回收或者父进程还没退出，那么就会如同zombie一样一直残留","text":"僵尸进程是指完成执行，但是仍有一个对应的PCB残留在进程表中，处于终止态的进程 一般而言，僵尸进程会被父进程wait进行回收，如果没有得到回收或者父进程还没退出，那么就会如同zombie一样一直残留 怎么产生 例如在socket中父进程大量地进行fork，并且没有wait，那么子进程结束之后就会变成僵尸进程 如何处理–信号量signal 子进程完成之后，系统会发送SIGCHLD信号给父进程 然而父进程对其默认处理是直接忽略，要想处理僵尸进程，那么需要使用wait来回收 那么如何处理信号量呢？下面我们将对signal(...), wait(...), waitpid(...)等函数进行说明 signal 123#include &lt;signal.h&gt;typedef void (*sighandler_t)(int);sighandler_t signal(int signum, sighandler_t handler); signum : 需要处理的信号类型 handler : 处理方案 wait &amp; waitpid 123#include &lt;sys/wait.h&gt;pid_t wait(int *statloc);pid_t waitpid(pid_t pd, int *statloc, int options); 当子进程完成，就会发送SIGCHLD信号给父进程，这时候，我们可以通过在handler中调用wait回收僵尸进程 12345678910#include &lt;signal.h&gt;#include &lt;sys/wait.h&gt;void sig_chld(int signo) &#123; pid_t pid; int stat; pid = wait(&amp;stat); //stat用来保存子进程的结束状态 //pid用来保存子进程的id号&#125; 但是，这个方案存在缺陷，如果在同一时间有多个SIGCHLD传来，那么只会有一个僵尸进程得到回收 因此，正确的解决方案是调用waitpid 12345678void sig_chld(int signo) &#123; pid_t pid; int stat; while ( (pid = waitpid(-1, &amp;stat, WNOHANG)) &gt; 0) &#123; printf(\"chlid %d terminated\\n\", pid); &#125;&#125;","categories":[],"tags":[{"name":"socket","slug":"socket","permalink":"http://originals-tz.github.io/tags/socket/"}]},{"title":"Socket之read,write函数","slug":"SocketReadWrite","date":"2018-04-12T16:00:00.000Z","updated":"2018-08-01T15:58:45.559Z","comments":true,"path":"2018/04/13/SocketReadWrite/","link":"","permalink":"http://originals-tz.github.io/2018/04/13/SocketReadWrite/","excerpt":"在socket中，read，write函数不同于一般的文件IO操作 下面开始分析这两个函数在socket中的行为","text":"在socket中，read，write函数不同于一般的文件IO操作 下面开始分析这两个函数在socket中的行为 write 12#include &lt;unistd.h&gt;ssize_t write(int fd, const void *buf, size_t count); 从函数声明我们可以看到，第一个是一个文件描述符，第二个是一个指向缓存区的指针，第三个则是要写入的数据量 write函数把buf的count字节内容写入文件描述符 成功，就返回写的字节数。失败，返回-1，并设置errno变量 那么就会有两种情况 a）返回值大于0，表示写入了部分或者全部数据，由于有可能一次无法将所有数据写入，因此需要通过返回值来确定剩余数据量 b）返回值小于0，表示出现了错误，我们要根据errno的值进行处理 EINTR：写的时候出现了中断错误 EPIPE：网络连接出现了问题 因此，普通的write函数无法满足我们的需求，我们需要写一个能够将数据完全写入以及能够处理错误的加强版write函数 12345678910111213141516171819ssize_t writen(int fd, const void *buf, size_t n) &#123; size_t nleft; //剩余数据 ssize_t nwritten; //已写入数据，用于移动指针 const const *ptr; //指向buf的指针 ptr = buf; nleft = n; while (nleft &gt; 0) &#123; if ((nwritten = write(fd, ptr, nleft)) &lt;= 0) &#123; if (nwritten &lt; 0 &amp;&amp; errno == EINTR) &#123; nwritten = 0; &#125; else &#123; return -1; &#125; &#125; nleft -= nwritten; ptr += nwritten; &#125;&#125; read 12#include &lt;unistd.h&gt;ssize_t read(int fd,void *buf,size_t count) read函数是负责从fd中读取内容.当读成功时,read返回实际所读的字节数 当读成功时,read返回实际所读的字节数 如果返回的值是0,表示已经读到文件的结束了 小于0表示出现了错误.并改写errno EINTR:中断错误 ECONNREST:网络连接出了问题 12345678910111213141516171819202122ssize_t readn(int fd, void *buf, size_t count) &#123; size_t nleft; //剩余数据量 ssize_t nread; //已读数据量 char *ptr; //指向缓存区的指针 ptr = buf; nleft = n; while (nleft &gt; 0) &#123; if ( (nread = read(fd, ptr, nleft)) &lt; 0 ) &#123; if (errno == EINTR) &#123; nread = 0; &#125; else &#123; return -1; &#125; &#125; else if (nread == 0) &#123; break; &#125; nleft -= nread; ptr += nread; &#125; return (n - nleft);&#125; socket中的缓冲区与blocking 每个socket被创建后，都会分配两个缓冲区，输入缓冲区和输出缓冲区 read，write函数都是和缓冲区进行IO互动 然而，缓冲区的大小是有限制的，其大小可以通过getsockopt获取，因此，当缓冲区满了，也就有了中断错误EINTR 缓冲区有以下特性 I/O缓冲区在每个TCP套接字中单独存在； I/O缓冲区在创建套接字时自动生成； 即使关闭套接字也会继续传送输出缓冲区中遗留的数据； 关闭套接字将丢失输入缓冲区中的数据 因为read和write的操作都是在缓冲区上进行，因而也有了所谓的阻塞模式(blocking) 试想，当缓冲区中没有数据的时候，read就会阻塞 那么当缓冲区的数据满了，那么write就会阻塞","categories":[],"tags":[{"name":"socket","slug":"socket","permalink":"http://originals-tz.github.io/tags/socket/"}]},{"title":"Copy Constructor","slug":"C++CopyConstructor","date":"2018-04-05T16:00:00.000Z","updated":"2018-08-21T02:26:21.996Z","comments":true,"path":"2018/04/06/C++CopyConstructor/","link":"","permalink":"http://originals-tz.github.io/2018/04/06/C++CopyConstructor/","excerpt":"有三种情况会使用到copy constructor 用一个object初始化另一个object 传参(pass by value) 返回值","text":"有三种情况会使用到copy constructor 用一个object初始化另一个object 传参(pass by value) 返回值 default memberwise initilization &amp; bitwise copy semantics link1，link2，link3 default memberwise initilization 如果我们没有为一个函数提供explicit copy constructor 那么当我们试图用一个object初始化另一个object的时候 内部就使用default memberwise initilization，然后defalut memberwise initilization又可以分为bitwise copy和default copy constructor 当遇到member class object的时候就会以递归的方式施行default memberwise initilization 123456789101112131415161718192021222324252627class String &#123;public: ...private: char *str; int len;&#125;;String str(\"hello\")String str2(str)-------------String copy constructor---------&#123; str2.str = str.str; str2.len = str.len;&#125;-------------String copy constructor----------// if the class has the memebre class objectclass Word &#123;public: ....private: int _count; String _word;&#125;; 那么Word会先拷贝_count然后再对_word实施memberwise initilization 就如同default constructor一样，一个default copy constructor的产生取决于它是否是trival，只有nontrival的instance会被生成 那么是否是trival就在于class是否展现出所谓的bitwise copy semantics bitwise copy semantics 首先，我们要明确一个class什么时候不展现出bitwise copy semantics 当class内含一个member object而且内含一个copy constructor时，无论是否被显式声明 当继承自一个含有copy constructor（无论是否被显式声明）的class 当class声明了一个或者多个virtual funciton 当class派生自一个含有virtual base class的继承串联 那么，编译器就会弃用bitwise copy而使用default copy constructor 一般而言，如果只含POD数据成员，一般不会合成一个default copy construcotr 最需要注意的是，default copy constructor并不是深拷贝，因此如果涉及到资源的分配，就需要程序员设计一个explicit copy constructor 详情见link3 那么值得讨论的是，为什么以上四种情况不会展现bitwise copy semantics？ 1.重新设定vptr 123456789101112131415class A &#123;public: virtual void get();&#125;;class B : public A &#123;public: void get(); virtual give();&#125;;void func(A a) &#123;&#125;B b;func(b); //发生sliced 因为a的空间大小和b(b+a)的空间大小不同 因此需要将b中b的部分切掉，保留a的部分 此时，如果a中的vptr仍指向b的vtbl（因为bitwise），那么就会blow up 但是如果是指针或者引用，也就是void func (const A &amp;a)则不会发生sliced,因为指针或者引用所引发的不是内存大小的改变，而是所指向内存的大小和内容的解释方式的改变 所以可以展现多态性，也就是可以将B传入func(const A &amp;a)并调用B::get() 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;class A &#123;public: virtual void get() &#123; std::cout &lt;&lt; \"A::get()\" &lt;&lt; std::endl; &#125;&#125;;class B : public A &#123;public: void get() &#123; std::cout &lt;&lt; \"B::get()\" &lt;&lt; std::endl; &#125;&#125;;void func(A&amp; a) &#123; a.get();&#125;int main() &#123; B b; A a; func(b); func(a); return 0;&#125;----output-----B::get()A::get() 因为不能使用bitwise的手法，所以default memberwise initilization就合成一个copy constructor，然后在里面显示设置vtpr 处理Virtual Base Class Subobject 还没弄懂virtual继承的对象模型，先留着 程序转化语义学 1.显式初始化操作 123X x0;X x1(x0);X x2 = x0 这时候会有一个必要的程序转化 1.先声明，这样子其中的初始化操作会被剔除 2.插入class的copy constructor 12345X x1;X x2;x1.X::X(x0);X2.X::X(x0); 2.参数的初始化 12345678910void func(X x0);X x0;func(x0);----------------X x0;X _temp;_temp.X::X(x0);func(_temp); // void func(X&amp; x0);//在func返回后，_temp.X::~X()会被调用 另一种实现方式是用拷贝构建的方式把实际参数直接构建在其应该的位置上 在函数返回前，destructor会被调用 3.返回值的初始化 12345678910111213141516X x = bar();X bar() &#123; X xx; return xx;&#125;----------------X x;bar(x)voidbar ( X&amp; _result ) &#123; X xx; _result.X::X(xx); return;&#125; 如果是函数指针也会进行转化 12345X (*pf) ();pr = bar;------------------X (*pr) (X&amp;);pr = bar Copy Constructor: 要还是不要 123456class Point3d &#123;public: Point3d(float x, float y, float z) &#123;&#125;private: float _x, _y, _z;&#125;; 如上所示，class里面的三个成员都是存储数值的 那么bitwise copy既安全又快速 那么我们就没必要设计一个copy constructor 实现copy constructor的最简单的方法如下 123Point3d(const Point3d &amp; rhs) &#123; memcpy(this, &amp;rhs, sizeof(Point3d));&#125; 然而不管是使用memcpy or memset 前提条件都应该是class内不含编译器产生的内部member，如vptr 一旦涉及到vptr的改变，就不要使用 例如以下这个错误使用的例子 12345678910111213class Pointer3d &#123;public: Point3d(float x, float y, float z); virtual ~Pointer3d();&#125;;Point3d::Point3d(float x, float y, float z) &#123; //编译器插入的内容，初始化vptr _vptr_Point3d = _vtbl_Point3d; //vptr清0\u0010\u0010！！！！！ memset(this, 0, sizeof(Point3d));&#125; 但如果涉及到资源的分配，例如指针获取资源 那么就需要我们设计一个copy constructor 这也就是何时使用深拷贝，何时使用浅拷贝的问题","categories":[],"tags":[{"name":"object model","slug":"object-model","permalink":"http://originals-tz.github.io/tags/object-model/"}]},{"title":"Default Constructor","slug":"C++DefaultConstructor","date":"2018-03-28T16:00:00.000Z","updated":"2018-08-21T02:26:39.296Z","comments":true,"path":"2018/03/29/C++DefaultConstructor/","link":"","permalink":"http://originals-tz.github.io/2018/03/29/C++DefaultConstructor/","excerpt":"首先我们需要认清一件事情 编译器会为我们的类生成default constructor(默认构造函数)之类的成员函数 但是关键在于，产生的条件是在需要的时候 那么,default constructor什么时候才会生成呢？ 让我们分情况来讨论","text":"首先我们需要认清一件事情 编译器会为我们的类生成default constructor(默认构造函数)之类的成员函数 但是关键在于，产生的条件是在需要的时候 那么,default constructor什么时候才会生成呢？ 让我们分情况来讨论 “带有Default Constructor”的 Member Class Object 如果一个class没有任何的构造函数，但是它内含一个member object(成员对象)，并且这个对象带有default constructor 那么为了构造这个member class object,编译器必须为这个class合成一个default constructor 例如 123456789class Foo &#123;public: Foo();&#125;;class Bar &#123;private: Foo foo;&#125;; 那么编译器就会为Bar生成一个Bar::Bar(),并插入对应的代码初始化member class object 1234Bar::Bar() &#123; //伪代码 foo.Foo::Foo();&#125; 如果显式定义了constructor,那么编译器就会扩张已存在的所有constructor,在其中安插如上的初始化代码 如果存在多个member class object并且每一个都要求调用default constructor进行初始化操作 那么在安插初始化代码的时候，就会按照member的声明顺序调用其default constructor &quot;带有Default Constructor&quot;的Base Class 类似的道理，如果某个class派生于一个拥有default constructor的base class(基类) 那么所进行的操作也和上面的一样,会在派生类中生成或者扩张构造函数，安插base class的constructor &quot;带有一个Virtual Function&quot;的Class 当 class声明或者继承一个virtual function class派生自一个继承串链，其中有一个或者更多的virtual base class(虚基类) 那么下面两个扩张将会在编译期间发生 编译器会产生一个vtbl(virtual table)，存放class的virtual function地址 在每一个class object中，一个指向vtbl的vptr会被合成出来 12345678910111213141516class Widget &#123;public: virtual void flip() = 0;&#125;;class Whistle : public Widget &#123;...&#125;;void callFlip(const Widget&amp; widget) &#123; widget.flip();&#125;void Foo() &#123; Whistle w; callFlip(w);&#125; 此时,widget.flip()的虚拟调用操作会被重写 1(*widget.vptr[1])(&amp;widget); // 为了调用Whistle::flip(this); 由于vptr指向的是一个vtbl，widget.vptr[1]就是对应的函数指针 那么调用函数就变成了(*widget.vptr[1])(&amp;widget) , &amp;widget是传入对应实例(例如w)的this指针 为了达到这种效果，编译器必须为每一个Widget object以及其dervied class的object的vptr指定正确的值用来指向正确的vtbl 这样的话，倘若一个class没有constructor，那么就会合成一个，如果存在，那么就会安插相应的vptr初始化代码 “带有一个Vitrual Base Class”的Class 12345678class X &#123;public : int i;&#125;;class A : public virtual X &#123;public : int j; &#125;;class B : public virtual X &#123;public : double d; &#125;;class C : public A, public B &#123;public : int k; &#125;;void foo (const A* pa) &#123; pa-&gt;i = 1024;&#125; 我们知道，在虚拟继承中virtual base class只有一个实例 那么我们必须确定virtual base class在derived class object中的位置 那么，编译器可能进行的改写如下 123void foo (const A* pa) &#123; pa-&gt;_vbcX-&gt;i = 1024; //_vbcX是编译器产生的指针，用来指向virtual base class X&#125; 这样子的话，我们必须保证_vbcX在构造期间完成，这就是合成一个default constructor的理由 总结 以上四种情况会让编译器为未声明constructor的class合成一个default constructor member class object拥有default constructor base class拥有default constructor (继承链中)存在vritual function,需要设置vptr的初始值 存在virtual base class，需要产生一个指向virtual base class的指针 注意下列误区 任何class如果没有定义default constructor，编译器就会合成一个出来 default constructor会显式设定class内每一个data member的默认值","categories":[],"tags":[{"name":"object model","slug":"object-model","permalink":"http://originals-tz.github.io/tags/object-model/"}]},{"title":"Socket API","slug":"SocketAPI","date":"2018-03-27T16:00:00.000Z","updated":"2018-08-21T02:29:04.443Z","comments":true,"path":"2018/03/28/SocketAPI/","link":"","permalink":"http://originals-tz.github.io/2018/03/28/SocketAPI/","excerpt":"socket学习","text":"socket学习 socket(…) 1234#include &lt;sys/socket.h&gt;int socket (int family, int type, int protocol);- success: return &gt;= 0- fail: return -1 family : 协议族，包括IPv4, IPv6… family 说明 AF_INET IPv4协议 AF_INET6 IPv6协议 AF_LOCAL Unix域协议 AF_ROUTE 路由套接字 AF_KEY 密钥套接字 type : 套接字类型，包括SOCK_STREAM(字节流), SOCK_DGRAM(数据报)… type 说明 SOCK_STREAM 字节流套接字 SOCK_DGRAM 数据报套接字 SOCK_SEQPACKET 有序分组套接字 SOCK_RAW 原始套接字 protocol : 某个协议类型常值，设置为0以选择给定family和type组合的系统默认值，包括TCP，UPD，SCTP protocol 说明 IPPROTO_TCP TCP传输协议 IPPROTO_UDP UDP传输协议 IPPROTO_STCP STCP传输协议 connect(…) 1234#include &lt;sys/socket.h&gt;int connect (int sockfd, const struct sockaddr *servaddr, socklen_t addrlen);- success: 0- fail: -1 sockfd：socket返回的套接字描述符 2，3是指向一个套接字结构的指针和结构的大小 值得注意的是，connect函数会导致当前套接字从CLOSED状态转移到SYS_SENT状态 若成功，则转移到established(已建立)状态 若失败，则该套接字不可用，必须关闭 我们不能对这样的套接字再次调用connect函数，必须close然后重新调用socket bind(…) 12#include &lt;sys/socket.h&gt;int bind(int sockfd, const struct sockaddr *myaddr, socklen_t addrlen); bind(…)的用处在于把一个协议地址赋予一个套接字 在服务器上，bind要绑定一个众所周知的端口 而在客户端上，这个可以使用内核分配的临时端口 listen() 12#include &lt;sys/socket.h&gt;int listen(int sockfd, int backlog); 当socket函数创建一个套接字的时候，它就被设置为一个将调用connect的客户套接字 而listen会将其转换成一个被动套接字，从而接受指向该套接字的连接请求 调用listen后，套接字会从close转换到listen状态 backlog:内核应该为相应套接字排队的最大连接数 我们必须认识到，内核为每一个给定的监听套接字维护两个队列 未完成连接队列 ： 每个这样的SYN分节对应其中一项：已由某个客户发出并到达服务器，而服务器正在等待完成相应的TCP三路握手 已完成连接队列 ： 每个已完成三路握手的客户端对应其中一项 当客户的SYN到达时，TCP就会在未完成连接队列中创建一个新项，然后相应三路握手的第二个分节 然后该项就会在队列中一直保留，直到三路握手的第三个分节到达或者超时为止, 此时服务器进入SYN_RECV状态,当服务器未收到客户端的ACK时，重发请求包，一直到超时，才将此条目从未连接队列删除 SYN攻击就是利用这个特性，通过发送大量的半连接请求，耗费CPU和内存资源 这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。 accept() 12#include &lt;sys/socket.h&gt;int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen); accept由TCP服务器调用，如果已完成连接队列为空，那么进程将被投入睡眠 如果accept成功，返回值则是一个全新的描述符,代表与客户的TCP连接 EINTR(系统中断) 在处理僵尸进程的时候，我们曾经为处理SIGCHLD信号调用了wait/waitpid函数 这时候，系统为了处理这个信号产生了一次中断，这会使得accept产生一个EINTR错误 有些内核可以自动重启某些被中断的系统调用，但是为了保证移植性（因为某些内核不支持重启），我们必须对返回的ENITR有所处理 12345678while (1) &#123; if ((connfd = accept(listenfd, (SA *) &amp;cliaddr, &amp;clilen)) &lt; 0) &#123; if (errno == EINTR) continue; else err_sys(\"accept error\"); &#125;&#125; close() 12#include &lt;unistd.h&gt;int close(int sockfd); 将套接字标记成已关闭，然后立即返回到调用进程 fork(…) &amp; exec(…) 123456#include &lt;unistd.h&gt;pid_t fork(void);int execl(...);int execv(...);....具体查阅exec函数族 fork()调用一次，返回两次 第一次在父进程返回，返回的是新生进程的ID 第二次在新生进程返回0 两次返回的意义非常明显，为了区分当前进程是父进程还是子进程，以此来执行不同的操作 fork的两种常见用法 创建一个自身副本 执行其他程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt; //fork#include &lt;stdlib.h&gt;#include &lt;sys/wait.h&gt; //waitpidint run(char *command,char *args) &#123; pid_t pid; int pip[2]; char string[100]; char *argv[5]; //获取程序名字 argv[0] = (char *) malloc (100 * sizeof(char)); strcpy (argv[0], command+2); //获取参数 int i = 1; argv[i] = (char *) malloc (10 * sizeof(char)); bzero(argv[i], sizeof(argv[i])); char *p = argv[i]; for (i = 1; *args != '\\0' &amp;&amp; *args != '\\n' &amp;&amp; i &lt; 5; args++) &#123; if (*args == ' ') &#123; i++; memset(argv[i], '\\0', sizeof(argv[i])); p = argv[i]; &#125; else &#123; *p = *args; p++; &#125; &#125; argv[++i] = NULL; //创建子进程 pipe(pip); pid = fork(); if (pid == 0) &#123; close(pip[0]); if (pip[1] != STDOUT_FILENO) &#123; if (dup2(pip[1], STDOUT_FILENO) != STDOUT_FILENO) return -1; close(pip[1]); &#125; execv(command,argv); &#125; else if (pip &gt; 0) &#123; waitpid(pid, NULL, 0); bzero(string, sizeof(string)); read(pip[0], string, sizeof(string)); close(pip[1]); close(pip[0]); printf(\"Program OUT &gt;&gt;\\n%s\", string); setbuf(stdin, NULL); &#125; else &#123; printf(\"i am dead!\\n\"); &#125; return 0;&#125; sockaddr_in 123456struct sockaddr_in &#123; short int sin_family; //2 unsigned short int sin_port; //2 struct in_addr sin_addr; ‘//4 unsigned char sin_zero[8]; //8 &#125;; test code Server.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstring&gt; //use bzero#include &lt;memory.h&gt; //use memset#include &lt;unistd.h&gt; //use fork, exec, read, write, close#include &lt;arpa/inet.h&gt; //use the struct, such as sockaddr #include &lt;sys/socket.h&gt; //use socket, bind, connect, listen, accept..class Server &#123;private: int serv_sock; char receive[100]; sockaddr_in serv_addr; sockaddr_in clnt_addr; socklen_t clnt_addr_size; pid_t childpid;public: void init(); void wait();&#125;;void Server::init()&#123; serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); //memset(&amp;serv_addr, 0, sizeof(serv_addr)); use bzero bzero(&amp;serv_addr, sizeof(serv_addr)); serv_addr.sin_family = AF_INET; //use IPv4 address serv_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); //server IP address serv_addr.sin_port = htons(1234); //port&#125;void Server::wait()&#123; bind(serv_sock, (struct sockaddr*)&amp;serv_addr, sizeof(serv_addr)); listen(serv_sock, 20); while (1) &#123; clnt_addr_size = sizeof(clnt_addr); int clnt_sock = accept(serv_sock, (struct sockaddr*)&amp;clnt_addr, &amp;clnt_addr_size); if ((childpid = fork()) == 0) &#123; read(clnt_sock, receive, 100); std::cout &lt;&lt; receive &lt;&lt; std::endl; write(clnt_sock, receive, sizeof(receive)); memset(receive, 0, sizeof(receive)); exit(0); &#125; close(clnt_sock); &#125;&#125;int main() &#123; Server myserver; myserver.init(); myserver.wait(); return 0;&#125; Client 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;memory.h&gt; //使用memset()#include &lt;unistd.h&gt; //use fork,exec, read, write, close#include &lt;arpa/inet.h&gt; //use the some struct#include &lt;sys/socket.h&gt; //use socket, bind, connect//#include &lt;pthread.h&gt;class Clinet &#123;private: char receive[100]; char sent[100]; int serv_sock; sockaddr_in serv_addr;public: Clinet(std::string server_ip = \"127.0.0.1\"); void connecting();&#125;;Clinet::Clinet(std::string server_ip) &#123; const char *ip = server_ip.c_str(); memset(&amp;serv_addr, 0, sizeof(serv_addr)); serv_addr.sin_family = AF_INET; //使用IPv4地址 serv_addr.sin_addr.s_addr = inet_addr(ip); //具体的IP地址,服务器的ip地址 serv_addr.sin_port = htons(1234); //端口，服务器开放的端口&#125;void Clinet::connecting() &#123; memset(&amp;sent, 0, sizeof(sent)); memset(&amp;receive, 0, sizeof(receive)); while (1) &#123; int sock; //创建套接字 if( (sock = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)&#123; std::cout &lt;&lt; \"creat socket fail\"; exit(0); &#125; //读取服务器传回的数据 if(connect(sock, (struct sockaddr*)&amp;serv_addr, sizeof(serv_addr)) &lt; 0)&#123; std::cout &lt;&lt; \"can not connect\" &lt;&lt; std::endl; exit(0); &#125; std::cin &gt;&gt; sent; //输入要发送的数据 write(sock, sent, sizeof(sent)); //发送数据 read(sock, receive, sizeof(receive)); //接收数据 std::cout &lt;&lt; \"message :\" &lt;&lt; receive &lt;&lt; std::endl; memset(&amp;sent, 0, sizeof(sent)); memset(&amp;receive, 0, sizeof(receive)); //关闭套接字 close(sock); &#125;&#125;using namespace std;int main(int argc, char const *argv[]) &#123; Clinet myclinet; std::string MyIp; std::cout &lt;&lt; \"Enter the ip to connect(1:use the default ip):\"; std::cin &gt;&gt; MyIp; if (MyIp == \"1\") &#123; myclinet = Clinet(); &#125; else &#123; myclinet = Clinet(MyIp); &#125; myclinet.connecting(); return 0;&#125;","categories":[],"tags":[{"name":"socket","slug":"socket","permalink":"http://originals-tz.github.io/tags/socket/"}]},{"title":"Object Lessons","slug":"C++ObjecLessons","date":"2018-03-23T16:00:00.000Z","updated":"2018-08-21T02:27:05.205Z","comments":true,"path":"2018/03/24/C++ObjecLessons/","link":"","permalink":"http://originals-tz.github.io/2018/03/24/C++ObjecLessons/","excerpt":"在C语言中，数据和函数是分开声明的，语言本身并不支持数据和函数之间的关联性 例如 123456789typedef struct point3d &#123; float x; float y; flaot z;&#125; Point3d;void Point3d_print &#123; //print x,y,z&#125; 而在C++中，则提供了抽象数据模型给予支持 12345class Point3d &#123;public: Point3d(float x...) : _x(x),...&#123;&#125; void print() &#123;//print x,y,z&#125;&#125; 然而，这时候就会有人问，加上了封装之后，布局的成本增加了多少？","text":"在C语言中，数据和函数是分开声明的，语言本身并不支持数据和函数之间的关联性 例如 123456789typedef struct point3d &#123; float x; float y; flaot z;&#125; Point3d;void Point3d_print &#123; //print x,y,z&#125; 而在C++中，则提供了抽象数据模型给予支持 12345class Point3d &#123;public: Point3d(float x...) : _x(x),...&#123;&#125; void print() &#123;//print x,y,z&#125;&#125; 然而，这时候就会有人问，加上了封装之后，布局的成本增加了多少？ 答案是并没有增加成本 class Point3d支持封装性质并没有给它带来任何空间和执行期的不良后果 不过你即将看到 C++的布局以及存储时间上的主要额外负担都是由virtual引起的 包括 virtual function virtual base class The C++ Object Model C++中，有两种class data members:static, nostatic 有三种class member functions:static,nostatic,virtual 思考如下代码在机器中的表现形式 123456789101112131415class Point &#123;public: Point(float xval); virtual ~Point(); float x() const; static int PointCount();protected: virtual ostream&amp; print(ostream &amp;os) const; float _x static int _point_count;&#125;; A Simple Object Model 在这个模型中 一个object就是一系列的slots(指针),每一个slot指向一个members member本身并不存放在object中，只有指向member的指针才会存放在object中 那么 size(obejct) = size(pointer) * count(member) A Table-driven Object Model 这个模型则把上面的模型进行了改进 他把member分成data和function，然后分别放在data memeber table和member function table中 object则存放指向这两个table的指针,data member table则直接持有data,而member function table则存放着一系列的slots,每一个slot指出一个member function 虽然这个模型没有实际应用到C++编译器中 但是member function table这种观念成为支持virtual function的一个有效方案 The C++ Object Model 在此模型中 non-static data member被配置到每一个object内，static data members则被存放在object之外 static 和 non-static function member也被存放在object之外 virtual functions则通过以下两个步骤来支持 1.每一个class产生一堆指向virtual的指针，放在表格中(vtbl) object 2.每一个object被安插一个指针(vptr)，指向相关的vtbl，vtpr的设定和重置都由每一个class的constructor, destructor和copy assignment运算符自动完成,每一个class所关联的type_info object也经由vtbl被指出来，通常被放在表格的第一个solt 加上继承 在虚拟继承的情况下，base class不管在继承中被派生多少次，永远只存在一个实例 那么base table应该是怎么样的呢？ 首先根据simple object model,我们可以在class object中放置slot指向base class 另外一种机制是，每一个class object都会被安放一个base table pointer 然后继承多个base class只需要改变base table而无需改变class object 但是无论哪一种机制，间接性的级数都会因为继承的深度而增加 例如以下这种继承链 Library_materials—&gt;Book—&gt;Rental_Book Rental_Book需要两次间接存储才能取到Library_materials的members 对象的差异 只有通过Pointer和Reference的间接处理，才能支持OO程序设计中所需的多态性质 在C++中，多态只存于一个个的public class体系中，并以如下的方式支持多态 隐式转换，例如dervied class指针转换成base class指针 virtual function机制 经由dynamic_cast和typeid运算符 然后，可以试着思考，需要多少内存才能表现一个class object？ nonstatic data members的总大小 加上由alignment的需求而填补上去的空间(alignment就是将数值调整到某数的倍数，32位机器alignment为4 bytes，可以使bus“运输量”达到最高效率 为了支持virtual而产生的额外负担(vptr) 指针的类型 一个指针，不管指向的类型是什么，指针本身所需的内存大小是固定的 但是一个指向整数的指针和一个指向template Array的指针有什么不同呢？ 首先，肯定的是，指针的内存需求是一样的 其次，它们之间的差异就在于其所寻址出来的object类型不同 换句话说，就是“指针类型”会教导编译器如何解释某个特定地址中的内存内容和大小 指向地址1000的整数指针，在32位机器上，将涵盖地址空间1000-1003 假设类ZooAnimal 123456789class ZooAnimal &#123;public: zooAnimal(); virtual ~ZooAnimal(); virtual void rotate();protected: int loc; string name;&#125;; 一个指向ZooAnimal的指针将跨越地址空间1000-1015(int-4 + string(int+char)-8 + vptr-4) 那么一个指向1000的void *的指针将涵盖怎么样的内存空间呢？ 我们并不知道，这也就是为什么void指针能够持有地址却无法操作其指向的object的缘故 加上多态之后 1234class Bear : public ZooAnimal &#123;...&#125;;Bear b;ZooAnimal za = b;za.rotate() //ZooAnimal::rotate() Q1：为什么za的vptr不指向Bear的vtbl？ Q2：为什么rotate调用的是ZooAnimal::rotate()? A1：如果某个object含有一个或者一个以上的vptrs，那些vptrs不会被用于初始化的source object所改变 A2：我们知道，pointer或者reference之所以支持多态，是因为它们可以改变所指向内存的大小和内容的解释方式 而直接进行dervied class object对base class object的赋值操作，因为object所占用的内存大小不一样 因此会对dervied class object进行对象切割以塞入更小的base class object中 于是乎dervied type的成分就会被完全切除，多态也无从表现","categories":[],"tags":[{"name":"object model","slug":"object-model","permalink":"http://originals-tz.github.io/tags/object-model/"}]},{"title":"创建型模式","slug":"CreatePattern","date":"2018-02-06T16:00:00.000Z","updated":"2018-08-21T02:28:07.842Z","comments":true,"path":"2018/02/07/CreatePattern/","link":"","permalink":"http://originals-tz.github.io/2018/02/07/CreatePattern/","excerpt":"设计模式之创建型模式","text":"设计模式之创建型模式 Factory Method 关于工厂模式的一个比较好的介绍:工厂设计模式有什么用？ - 郭小成的回答 - 知乎 解决了硬编码 一个类如果发生了变动,假使你使用了硬编码(直接new),那么你还得找到所有new的地方一个一个更改 而将new的过程放入Factory中,那么你只用改变Factory就行了 Abstract Factory 抽象工厂模式提供了一种方式，可以将一组具有同一主题的单独的工厂封装起来(如果不把同一主题的封装起来,而是一味使用Factory Method,代码量会急剧膨胀) 在正常使用中，客户端程序需要创建抽象工厂的具体实现，然后使用抽象工厂作为接口来创建这一主题的具体对象 不同的theme,控件的观感也不同 我们可以定义一个ThemeFactory作为base class(interface) 然后通过继承(实现)衍生出各种(derived)class以此来实现不同的theme 每一种theme都有不同风格的widget,我们将其称之为factory的product 123456class ThemeFactory &#123;public: makeWindows(); //这些就是product makeMenuBar(); make.........;&#125; 然后关于Abstract Factory 优点是 分离了具体的类 使得便于交换产品的系列（通过创建不同的derived class) 它有利于产品的一致性(每一个derived class所产出的产品都是一一致的) 缺点是 难以加入新种类的产品(当base class加入新产品时,derived class的也要加入新的产品,这就要修改大量的derived class) 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;class Windows&#123;&#125;;class windowsMacStyle : public Windows&#123;&#125;;class windowsLinuxStyle : public Windows();class ThemeFactory &#123; //base class确保了产品的一致性public: //factory method virtual void makeWindows() = 0;&#125;;class MacThemeFactory : public ThemeFactory &#123;public: virtual void makeWindows() &#123; std::cout &lt;&lt; \"this is a windows which is mac style\" &lt;&lt; std::endl; //return new windowsMacStyle(); &#125;&#125;;class LinuxThemeFactory : public ThemeFactory &#123;public: virtual void makeWindows() &#123; std::cout &lt;&lt; \"this is a windows which is linux style\" &lt;&lt; std::endl; //return new windowsLinuxStyle(); &#125;&#125;;int main() &#123; ThemeFactory *test = new LinuxThemeFactory(); test-&gt;makeWindows(); delete test; test = new MacThemeFactory(); //改变产品的系列 test-&gt;makeWindows(); delete test; return 0;&#125; Builder Builder模式由Director和Builder组成 虽然名为Builder,但是Director才是重点 将一个复杂对象的构建和它的表示分离,使得同样的创建过程可有不同的表示 效果: 可以改变一个产品的内部表示 将构建代码和表示代码分开 可以对构建过程有更加精细的控制 相对于Abstract Factory,Builder重视的是一个构建的过程(direct),而Abstract Factory只是提供零件的过程 可以这么认为,Abstract Facotry套上Builder模式也可以产生一个新的Builder( director + builder ) 想构建不同的产品？新增builder就好 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;string&gt;class Computer &#123;private: std::map&lt;std::string, std::string&gt; computer;public: void show() &#123; auto iter = computer.begin(); while (iter != computer.end())&#123; std::cout &lt;&lt; iter-&gt;first &lt;&lt; \":\" &lt;&lt; iter-&gt;second &lt;&lt; std::endl; iter++; &#125; &#125; void set(std::string type, std::string product) &#123; computer[type] = product; &#125;&#125;;class Builder &#123;public: virtual void BuildCPU() = 0; virtual void BuildMainboard() = 0; virtual void BuildHD() = 0; virtual Computer getComputer() = 0;&#125;;class BuilderA : public Builder &#123;private: Computer compter;public: virtual void BuildCPU() &#123; std::cout &lt;&lt; \"add intel CPU\" &lt;&lt; std::endl; compter.set(\"CPU\", \"Inter\"); &#125; virtual void BuildMainboard() &#123; std::cout &lt;&lt; \"add MSI MainBoard\" &lt;&lt; std::endl; compter.set(\"MainBoard\", \"MSI\"); &#125; virtual void BuildHD() &#123; std::cout &lt;&lt; \"add hgst HD\" &lt;&lt; std::endl; compter.set(\"HD\", \"hgst\"); &#125; virtual Computer getComputer() &#123; return compter; &#125;&#125;;class BuilderB : public Builder &#123;private: Computer compter;public: virtual void BuildCPU() &#123; std::cout &lt;&lt; \"add AMD CPU\" &lt;&lt; std::endl; compter.set(\"CPU\", \"AMD\"); &#125; virtual void BuildMainboard() &#123; std::cout &lt;&lt; \"add ROG MainBoard\" &lt;&lt; std::endl; compter.set(\"MainBoard\", \"ROG\"); &#125; virtual void BuildHD() &#123; std::cout &lt;&lt; \"add SAMSUMG HD\" &lt;&lt; std::endl; compter.set(\"HD\", \"SAMSUMG\"); &#125; virtual Computer getComputer() &#123; return compter; &#125;&#125;;class Director &#123;public: void Construct(Builder *builder) &#123; builder-&gt;BuildCPU(); builder-&gt;BuildMainboard(); builder-&gt;BuildHD(); &#125;&#125;;int main() &#123; Builder *builder = new BuilderA(); Director p; std::cout &lt;&lt; \"construct the computer\" &lt;&lt; std::endl; p.Construct(builder); //指派一个装配人员(此处可以复合Abstract Factory) Computer computer = builder-&gt;getComputer(); std::cout &lt;&lt; \"\\nShow computer\" &lt;&lt; std::endl; computer.show(); delete builder; return 0;&#125; Prototype 通过原型实例指定对象种类，并且通过拷贝这些原型创建新的对象 原型模式是创建型模式的一种，其特点在于通过“复制”一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的“原型”，这个原型是可定制的。 原型模式多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程序运行更高效；或者创建值相等，只是命名不一样的同类数据。 Prototype模式的核心就是，复制整体，修改部分，形成一个新的实例 举个不是特别恰当的例子 例如Jack需要多份简历,简历大部分都是相同的,只有工作经验不同 因此，只需要复制一份之前的简历,再修改一下工作经验即可 例如 123456789101112131415161718class Resume &#123;private: std::string Name; int Age; std::string Experience;public: Resume(std::string name, int age, std::string experience); Resume * Clone() &#123;return new Resume(*this);&#125;; void SetPersonalInfo(); void SetExperience(std::string expr);&#125;;int main() &#123; Resume *resume1 = new Resume(\"Jack\", 26, \"Work on A Company\"); Resume *resume2 = resume1-&gt;Clone(); resume2-&gt;SetExperience(\"Work on B Company\") return 0;&#125; 可能这个例子不是特别能说明原型模式的好处,但是如果在构造时需要设置多个属性(例如20个) 但是大部分属性都是相同，只需要修改部分属性,那么原型模式的好处就会大大体现出来 SingleTon 保证一个类只有一个实例,并提供一个访问它的全局访问点 对于一些类来说,只有一个实例是很重要的 例如：打印机，数据库等 SingleTon的效果是 对唯一实例的受控访问 缩小名空间,放置全局变量污染 允许对操作和表示的精化 允许可变数目的实例 比类操作更灵活 实现： 如何保证一个唯一的实例？ 可以将创建实例的操作放在一个类操作后面 例如 12345678910111213141516class Singleton &#123;private: static Singleton* _instance;protected: Singleton()&#123;&#125;;public: static Singleton * Instance();&#125;;Singleton * Singleton::_instance = nullptr;Singleton * Singleton::Instance()&#123; if (!_instance) _instance = new Singleton; return _instance;&#125;","categories":[],"tags":[{"name":"DesignPatterns","slug":"DesignPatterns","permalink":"http://originals-tz.github.io/tags/DesignPatterns/"}]},{"title":"c++ 模板实参推断","slug":"C++TypeInference","date":"2017-09-26T16:00:00.000Z","updated":"2018-08-21T02:27:16.667Z","comments":true,"path":"2017/09/27/C++TypeInference/","link":"","permalink":"http://originals-tz.github.io/2017/09/27/C++TypeInference/","excerpt":"于函数模板，编译器用实参来推断模板参数 这个过程成为模板实参推断","text":"于函数模板，编译器用实参来推断模板参数 这个过程成为模板实参推断 类型转换与模板类型参数 一般而言，不会转化实参以匹配已有的实例化，相反，会产生新的实例化，或产生不了实例化，报错。 只有两个例外： const转换： 如果模板形参为const引用，则其可以接受const或非const引用 如果模板形参为const指针，则其可以接受const或非const指针 如果模板形参不是引用或指针 （值传递），则形参和实参都忽略const 数组或函数到指针的转换 如果模板形参不是引用或指针（值传递），则数组会转化为指针，数组实参将当作指向其第一个元素的指针； 如果模板形参不是引用或指针（值传递），则函数会转化为指针，函数实参将当作指向函数类型的指针； 123456789101112template &lt;typename T&gt; T fobj(T, T);//值传递 template &lt;typename T&gt; T fref(const T&amp;, const T&amp;);//引用 string s1(\"a value\"); const string s2(\"another value\"); fobj(s1,s2);//值传递，const被忽略 fref(s1,s2);//引用，s1也被转成了const引用 int a[10], b[42]; fobj(a, b);//值传递，数组被转成指针，T被推断为int *,f(int*,int*) fref(a, b);//Error!!,引用，a导致T被推断为int(&amp;T)[5]、b导致T被推断为int(&amp;T)[5]，矛盾 函数模板显式实参 定义一个模板 12template&lt;typename T1, typename T2&gt;T1 sum(T1 s); 从这个函数实参我们仅仅可以推断出T2的类型 因此，为了推断出T1,必须为显式指定这两个类型 1auto val2=sum&lt;int, long&gt;(i); 尾指返回类型与类型转换 当你遇到这种情况 1234template&lt;typename T&gt;??? &amp;fcn(T beg, T end) &#123; return *beg;&#125; 这时，你无法确定返回值是什么， 你知道的只有接收一对迭代器和要返回一个元素的引用 这时你就需要decltype 1234template&lt;typename T&gt;auto fcn(T beg, T end)-&gt;decltype(*beg) &#123; return *beg;&#125; 要是你想返回的不是引用而是一个值 那么，你需要remove_reference::type 12345template&lt;typename T&gt;auto fcn(T beg, T end)-&gt;typename remove_reference&lt;decltype(*beg)&gt;::type &#123; return *beg;&#125; 根据指针类型来推断模板实参 123template &lt;typename T&gt;T compare(const T&amp;, const T&amp;);int (*f)(const int&amp;, const int&amp;) = compare; 此时，T=int; 12345template &lt;typename T&gt;T compare(const T&amp;, const T&amp;);void func(int(*)(const int&amp;, const int&amp;));void func(string(*)(const string&amp;, const string&amp;));func(compare);//error 因为无法判断使用compare的哪一个版本 想要成功调用，只能显式声明 1func(compare&lt;int&gt;);","categories":[],"tags":[{"name":"template","slug":"template","permalink":"http://originals-tz.github.io/tags/template/"}]},{"title":"8086微处理器","slug":"8086","date":"2017-09-08T16:00:00.000Z","updated":"2018-08-21T02:25:54.248Z","comments":true,"path":"2017/09/09/8086/","link":"","permalink":"http://originals-tz.github.io/2017/09/09/8086/","excerpt":"内部功能结构 总线接口部件 BIU 作用：与CPU外部传送指令代码或者数据，如取指令时把指令送到指令队列，执行指令时负责数据交换 组成： 段地址寄存器： CS：代码段首地址的高16位 DS：数据段首地址的高16位 ES：另一个数据段首地址的高16位 SS：堆栈区数据段首地址的高16位 16位的指令指针寄存器IP：存放着下一条地址的偏移量，即CS * 16 +IP=下一条指令的地址 20位的地址加法器：段基址 x 16(左移4位) + 偏移地址 = 物理地址 指令队列缓冲器：存放预取指令的指令队列 内部暂存器：暂存输入输出信息的寄存器 总线逻辑控制器：控制总线上的信息传输","text":"内部功能结构 总线接口部件 BIU 作用：与CPU外部传送指令代码或者数据，如取指令时把指令送到指令队列，执行指令时负责数据交换 组成： 段地址寄存器： CS：代码段首地址的高16位 DS：数据段首地址的高16位 ES：另一个数据段首地址的高16位 SS：堆栈区数据段首地址的高16位 16位的指令指针寄存器IP：存放着下一条地址的偏移量，即CS * 16 +IP=下一条指令的地址 20位的地址加法器：段基址 x 16(左移4位) + 偏移地址 = 物理地址 指令队列缓冲器：存放预取指令的指令队列 内部暂存器：暂存输入输出信息的寄存器 总线逻辑控制器：控制总线上的信息传输 执行部件 EUP 组成 通用寄存器 AX BX CX DX 专用寄存器 BP:基数指针寄存器:指向栈底 SP:堆栈指针寄存器:指向栈顶 SI: DI 算术逻辑部件ALU:计算算术逻辑运算, EU控制器: 标志寄存器 SF(sign) ZF(zero) PF(parity) CF(carry) AF(auxiliary carry) OF(overflow) DF(direction) IF(interrupt enable) TF(trap) 寻址方式 立即寻址 1mov AX, 3412H 无法计算源操作数的物理地址 操作数直接包含在指令中，即可以直接从指令队列中获取立即数 寄存器寻址 1mov AX, BX 无法计算源操作数的物理地址 操作数包含在寄存器中 内存器寻址 操作数处于内存的数据段中，指令中指明了数据所在的地址 直接寻址 1mov AX, [3412H] 地址为DS * 10H + 3412H 寄存器间接寻址 1mov AX, [BX] 有效地址操作数包含在寄存器中 当没有前缀指令表明操作数在哪一段时(ES:[BX]),则当用BP来间接寻址时,则段寄存器默认为SS,BX、DI、SI默认寄存器为DS 寄存器相对寻址 1mov AX,[BX+6824H] 基址加变址寄存器寻址方式 1mov AX,[BX+SI] 相对的基址和变址寻址方式 1mov AH,[BX+SI+2468]","categories":[],"tags":[{"name":"other","slug":"other","permalink":"http://originals-tz.github.io/tags/other/"}]}]}